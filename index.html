 <!-- Optimized WAGMIK Site -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Basic Meta -->
<meta name="description" content="WAGMIK ‚Äî The next legendary meme coin movement on Solana.">
<meta name="theme-color" content="#1a0e2d" />

<!-- Social Preview (Open Graph) -->
<meta property="og:title" content="WAGMIK ‚Äì Bonks Cousin rises from the trenches.">
<meta property="og:description" content="Join the climb. Meme. Trade. Dominate. Powered by Solana.">
<meta property="og:image" content="https://wagmik.xyz/preview.png">
<meta property="og:url" content="https://wagmik.xyz">
<meta property="og:type" content="website">

<!-- Twitter Preview -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="WAGMIK ‚Äì Bonks Cousin rises from the trenches.">
<meta name="twitter:description" content="The next meme empire, born on Solana.">
<meta name="twitter:image" content="https://wagmik.xyz/preview.png">

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "WebApplication",
  "name": "WAGMIK",
  "url": "https://wagmik.xyz",
  "description": "WAGMIK is a meme coin hub and meme generator on Solana. Create, share, and swap without leaving the page.",
  "applicationCategory": "FinanceApplication",
  "operatingSystem": "ALL",
  "browserRequirements": "Requires JavaScript",
  "image": "https://wagmik.xyz/preview.png"
}
</script>

  <!-- All original and functional code preserved -->

 <link rel="manifest" href="manifest.json" />

 <link rel="icon" type="image/png" href="icons/icon-192.png">

  <style>
    html {
      scroll-behavior: smooth;
    }
    body {
      font-family: 'Segoe UI', sans-serif;
      background-color: #1a0e2d;
      margin: 0;
      padding: 0;
      overflow-x: hidden;
    }
    section {
      padding: 60px 20px;
      max-width: 960px;
      margin: auto;
    }
    h1, h2, h3 {
      color: #ffe06b;
      text-shadow: 2px 2px 6px rgba(0,0,0,0.75);
    }
    p {
      color: #fff;
      text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
    }

   body, .section p, .tokenomics-content li {
  text-shadow: 2px 2px 6px rgba(0, 0, 0, 0.75);
}
   

  body {
  overflow-x: hidden;
}

html, body {
  max-width: 100%;
  overflow-x: hidden;
}


   header::before {
  content: none;
}

    header h1, header p {
      position: relative;
      z-index: 2;
    }

    .section {
      padding: 60px 20px;
      max-width: 900px;
      margin: auto;
      text-align: center;
    }

    .section h2 {
      font-size: 2.2em;
      color: #FFDE6A;
      text-align: center;
    }

    .about p, .lore p {
      font-size: 1.4em;
      line-height: 1.6;
      text-align: center;
      margin: 0 auto;
    }

    .quote {
      margin-top: 30px;
      padding: 20px;
      background: rgba(255, 255, 255, 0.08);
      border-radius: 10px;
      font-style: italic;
      text-align: center;
      color: white;
    }

    .cta {
      display: block;
      width: fit-content;
      margin: 30px auto;
      background-color: #ff4fd8;
      color: #000;
      font-weight: bold;
      padding: 14px 28px;
      border-radius: 25px;
      text-decoration: none;
    }


/* Meme Gallery */
.gallery-wrapper {
  overflow: hidden;
  width: 100%;
  margin-top: 30px;
  border-radius: 12px;
  position: relative;
}

.gallery-track {
  display: flex;
  gap: 18px;
  animation: scrollGallery 20s linear infinite;
  padding: 10px;
}

.gallery-meme {
  height: 160px;
  border-radius: 8px;
  transition: transform 0.3s ease, box-shadow 0.3s ease;
  cursor: pointer;
}

.gallery-meme:hover {
  transform: scale(1.1);
  box-shadow: 0 6px 18px rgba(255, 255, 255, 0.25);
}

/* Lightbox effect */
.lightbox {
  display: none;
  position: fixed;
  z-index: 999;
  top: 0; left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0,0,0,0.85);
  justify-content: center;
  align-items: center;
}

.lightbox img {
  max-width: 90%;
  max-height: 90%;
  border-radius: 12px;
  box-shadow: 0 0 30px rgba(255,255,255,0.3);
  animation: fadeIn 0.4s ease-in-out;
}

@keyframes scrollGallery {
  0%   { transform: translateX(0); }
  100% { transform: translateX(-50%); }
}

/* Hide floating lore by default */
.floating-lore {
  display: none;
}

@media (min-width: 768px) {
  .floating-lore-wrapper {
    position: relative;
    min-height: 0; /* Allows scrolling to reveal floating lore */
    z-index: 5;
  }
 }
 

 @media screen and (min-width: 768px) {
  .floating-lore {
    position: fixed;
    top: 40px;       /* adjust as needed to move closer to top */
    right: 40px;      /* adjust as needed to move closer to the right edge */
    max-width: 240px;
    z-index: 999;
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: 20px;
    pointer-events: none;
  }

  .floating-lore .lore-chapter {
    background: rgba(0, 0, 0, 0.65);
    color: #ffde6a; 
    padding: 10px 14px;
    border-radius: 12px;
    font-size: 1em;
    text-align: right;
    text-shadow: 1px 1px 3px black;
    max-width: 100%;
    opacity: 0;
    transform: translateY(30px);
    transition: opacity 0.6s ease, transform 0.6s ease;
  }

  .floating-lore .lore-chapter.visible {
    opacity: 1;
    transform: translateY(0);
  }
}

.coin-fall {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 2;
  }

.coin {
  position: absolute;
  width: 32px;
  height: 32px;
  background: url('circle.png') center/cover no-repeat;
  animation: fall 6s linear infinite;
  }

    @keyframes fall {
      0% { transform: translateY(-50px) rotate(0deg); opacity: 1; }
      100% { transform: translateY(100vh) rotate(360deg); opacity: 0; }
    }


footer {
  display: flex;
  justify-content: center;
  align-items: center;
  flex-direction: column;
  width: 100%;
  text-align: center;
  padding: 20px 0;
  font-size: 0.95em;
  color: #fff;
}

.body-background-fade {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 120px; /* adjust for stronger/softer fade */
  background: linear-gradient(to bottom, rgba(26, 14, 45, 1), rgba(26, 14, 45, 0));
  z-index: 1;
  pointer-events: none;
}


/* Floating Buttons */
.floating-button {
  position: fixed;
  right: 20px;
  z-index: 1001;
  padding: 12px 18px;
  border-radius: 20px;
  font-weight: 600;
  border: none;
  cursor: pointer;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
  transition: background 0.3s;
}

.lore-toggle-btn {
  bottom: 140px;
  background: #ff4fd8;
}

.degen-toggle-btn {
  bottom: 80px;
  background: #ffe06b;
}

.meme-toggle-btn {
  bottom: 20px;
  background: #50f7ff;
}

@media (max-width: 768px) {
  body {
    background-size: cover; /* fix zoomed background */
  }

  header {
    padding: 60px 10px 30px;
    background-position: center top;
  }

  .section {
    padding: 40px 15px;
  }

  .section h2 {
    font-size: 1.8em;
  }

  .about p,
  .lore p,
  .tokenomics-content li {
    font-size: 1.1em;
    padding: 0 5px;
  }

  .cta {
    font-size: 0.95em;
    padding: 10px 20px;
  }

  .lore-chapter {
    font-size: 1.1em;
    padding: 10px 12px;
    max-width: 90vw;
  }

  iframe {
    height: 400px;
  }

  .gallery-meme {
    height: 120px;
  }

  .token-logo {
    width: 90px;
  }

  footer {
    font-size: 0.85em;
    padding: 16px 10px;
  }
}

@media (max-width: 768px) {

  .section.about {
    margin-top: -20;
  }

    .meme-toggle-btn {
      bottom: 20px;
      background: #50f7ff;
    }
  }

   /* Modal Base */
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(20, 10, 40, 0.92);
      backdrop-filter: blur(6px);
      z-index: 1000;
      padding: 40px 20px;
      overflow-y: auto;
      box-sizing: border-box;
      justify-content: center;
      align-items: center;
      flex-direction: column;
    }

    .modal.active {
  z-index: 9999;
  display: flex;
  flex-direction: column;
}

    .modal .close-btn {
      position: absolute;
      top: 15px;
      right: 20px;
      font-size: 1.8em;
      background: transparent;
      border: none;
      color: white;
      cursor: pointer;
    }

  .modal {
  pointer-events: auto;
  touch-action: manipulation;
  z-index: 9999;
}

    /* Lore Modal */
    #loreModal {
      background: linear-gradient(rgba(20, 10, 40, 0.4), rgba(20, 10, 40, 0.4)), url('lore.png') center center no-repeat;
      background-size: cover;
      color: #ffe06b;
    }

    .lore-chapter {
      margin-bottom: 18px;
      font-size: 1.2em;
      max-width: 600px;
      background: rgba(0,0,0,0.5);
      padding: 12px;
      border-radius: 10px;
    }

    /* Degen Modal */
    #degenModal h2 {
      color: #ffe06b;
      margin-bottom: 16px;
    }

    #degenProphecy {
      font-size: 1.4em;
      font-style: italic;
      text-align: center;
    }

/* Meme Modal */
#memeModal {
  background: linear-gradient(rgba(20, 10, 40, 0.9), rgba(20, 10, 40, 0.9)), url('console-layout.png') center center no-repeat;
  background-size: cover;
}

#memeModal select,
#memeModal input,
#memeModal button {
  touch-action: manipulation;
  -webkit-tap-highlight-color: transparent;
}

/* Base Styles */
.console-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 20px;
  max-width: 800px;
  margin: 0 auto;
  position: relative;
}

.console-controls {
  display: flex;
  flex-direction: column;
  gap: 12px;
  width: 100%;
  max-width: 400px;
}

.console-controls input,
.console-controls select,
.console-controls button {
  padding: 10px;
  font-size: 1em;
  border-radius: 8px;
  border: none;
  background: linear-gradient(135deg, #ff4fd8 0%, #ffe06b 100%);
  color: #000;
  font-weight: bold;
  cursor: pointer;
}

.button-row {
  display: flex;
  gap: 10px;
  justify-content: space-between;
}

canvas#memeCanvas {
  width: 90%;
  max-width: 360px;
  height: auto;
  margin: 20px auto 0;
  display: block;
  border: 2px dashed white;
  touch-action: none;
}

.console-container img.console-bg {
  display: none;
}

.console-controls,
.console-canvas {
  position: relative;
  z-index: 1;
}

.floating-buttons {
  position: fixed;
  right: 20px;
  bottom: 20px;
  display: flex;
  flex-direction: column;
  gap: 20px;
  z-index: 1001;
}

/* Mobile Styles */
@media (max-width: 768px) {
  .console-bg {
    content: url('mobile-console-layout.png');
    position: absolute;
    top: 0;
    left: 0;
    z-index: 0;
    opacity: 0.3;
  }

  .console-controls {
    padding: 0 10px; /* ‚¨ÖÔ∏è NEW: give mobile some horizontal breathing room */
  }

  .console-controls input,
  .console-controls select,
  .console-controls button {
    font-size: 0.95em;       /* ‚¨ÖÔ∏è NEW: slightly larger text for readability */
    padding: 10px;
    border-radius: 8px;
    border: none;
    font-family: inherit;
    font-weight: 600;        /* ‚¨ÖÔ∏è NEW: make labels bold for clarity */
    pointer-events: auto !important;
    touch-action: manipulation;
  }

  .button-row {
    flex-direction: column;  /* ‚¨ÖÔ∏è NEW: stack buttons vertically */
    gap: 10px;
    width: 100%;
    margin-top: 10px;
  }

  .button-row button {
    width: 100%;             /* ‚¨ÖÔ∏è NEW: make each button full width */
    background: linear-gradient(135deg, #ff4fd8 0%, #ffe06b 100%);
    color: #000;
    font-weight: bold;
    border: none;
    border-radius: 10px;
    padding: 12px 16px;
  }

  .console-btn:hover {
    background: #ffd700;
    color: #000;
    font-weight: bold;
  }

  .floating-button:hover {
    opacity: 0.9;
    transform: scale(1.05);
  }
}

/* Desktop override */
@media (min-width: 768px) {
  .console-container {
    flex-direction: row;
    align-items: flex-start;
    justify-content: space-between; /* ‚¨ÖÔ∏è ensures spacing between sides */
    gap: 40px;                      /* ‚¨ÖÔ∏è add space between controls and canvas */
  }

  .console-controls {
    width: 300px;
    max-width: 300px;
  }

  canvas#memeCanvas {
    width: 360px;
    height: 360px;
  }

 .console-canvas {
  width: 360px;
  max-width: 100%;
 }
}

/* Floating App Logos (Left Center) */
.floating-apps {
  position: fixed;
  top: 50%;
  left: 12px;
  transform: translateY(-50%);
  display: flex;
  flex-direction: column;
  gap: 16px;
  z-index: 1002;
  pointer-events: auto;
}

.app-logo {
  width: 44px;
  height: 44px;
  border-radius: 12px;
  box-shadow: 0 4px 10px rgba(0,0,0,0.5);
  transition: transform 0.2s ease, box-shadow 0.2s ease;
  cursor: pointer;
  pointer-events: auto;
}

.app-logo:hover {
  transform: scale(1.1);
  box-shadow: 0 6px 14px rgba(255, 255, 255, 0.3);
}

/* Mobile adjustments */
@media (max-width: 768px) {
  .floating-apps {
    left: 6px;
    gap: 12px;
  }

  .app-logo {
    width: 36px;
    height: 36px;
  }
}

@media (min-width: 769px) {
  .lore-toggle-btn,
  .degen-toggle-btn,
  .meme-toggle-btn {
    visibility: visible;   /* fix this line */
    pointer-events: auto;
  }
}

canvas {
  touch-action: none; /* üî• Stops browser scroll when touching canvas */
}

@media (max-width: 768px) {
  #rotationSliderWrapper {
    display: none !important;
  }
}

@media (max-width: 768px) {
  .console-controls .button-row button:nth-child(1), /* Preview */
  .console-controls .button-row button:nth-child(2)  /* Download */ {
    display: none;
  }

  /* Move Reset up where Preview was */
  .console-controls .button-row button:nth-child(3) {
    width: 100%;
    margin-top: 0;
  }
}

input, select, textarea, button {
  touch-action: manipulation !important;
}

#controlsWrapper select,
#controlsWrapper input[type="text"] {
  pointer-events: auto;
  z-index: 10;
  position: relative;
}

@media (min-width: 768px) {
  .lore-toggle-btn {
    display: none;
  }
}

   @media (max-width: 768px) {
  #rotationSliderWrapper,
  .console-btn:nth-child(1),  /* Preview */
  .console-btn:nth-child(2) { /* Download */
    display: none !important;
  }

  .console-btn:nth-child(3) {
    width: 100%;
    margin-top: 0.5rem;
  }

  .console-container {
    overflow-y: auto;
    max-height: 85vh;
    touch-action: none;
  }

  .lore-toggle-btn {
    display: block;
  }
}

canvas#memeCanvas {
¬† touch-action: none; /* allow full drag behavior */
}

body, html {
¬† touch-action: auto !important; /* reset global block if it lingers */
}

   /*
@media (max-width: 768px) {
¬† .modal.active {
¬† ¬† max-height: 100vh !important;
¬† ¬† overflow-y: auto !important;
¬† ¬† display: flex !important;
¬† ¬† flex-direction: column;
¬† }
}
   */

   /* üü£ Share Modal Wrapper */
.share-modal.hidden {
  display: none;
}

.share-modal {
  position: fixed;
  z-index: 9999;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0,0,0,0.85);
  backdrop-filter: blur(6px);
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 16px;
  box-sizing: border-box;
}

/* üü° Share Modal Inner Content */
.share-modal .modal-content {
  background: #1a1a1a;
  color: white;
  border-radius: 12px;
  padding: 20px;
  max-width: 340px;
  width: 100%;
  text-align: center;
  box-shadow: 0 0 10px rgba(255,255,255,0.2);
}

.share-modal .modal-content h2 {
  margin-top: 0;
  font-size: 1.3em;
}

.share-modal .modal-content ul {
  list-style: none;
  padding: 0;
  margin: 16px 0;
  text-align: left;
  font-size: 0.95em;
}

.share-modal .modal-content li {
  margin-bottom: 8px;
  line-height: 1.4;
}

/* üü¢ Button Group */
.share-modal .button-container {
  display: flex;
  gap: 10px;
  margin-top: 20px;
  justify-content: center;
  flex-wrap: wrap;
}

.share-modal .button-container button {
  flex: 1;
  padding: 10px;
  font-weight: bold;
  border: none;
  border-radius: 8px;
  background: linear-gradient(to right, #ff00cc, #ffcc00);
  color: black;
  cursor: pointer;
  font-size: 1em;
}

   @media (max-width: 768px) {
  .share-modal {
    align-items: flex-start;
    padding-top: 60px;
    padding-bottom: 40px;
    overflow-y: auto;
  }

  .share-modal .modal-content {
    max-width: 95%;
    font-size: 0.95em;
    padding: 16px;
  }

  .share-modal .modal-content ul {
    font-size: 0.9em;
    line-height: 1.5;
  }

  .share-modal .button-container {
    flex-direction: column;
    gap: 12px;
  }

  .share-modal .button-container button {
    width: 100%;
    font-size: 1em;
    padding: 12px;
  }
}

section.about *,
section.lore *,
section.bonk-tribute *,     /* Bonk Tribute */
section#meme-gallery *,
section:nth-of-type(6) *,     /* Jupiter Buy */
.tokenomics-section * {
  text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.85);
}

.hero-banner {
  background-image: url('banner.png');
  background-size: cover;
  background-repeat: no-repeat;
  background-position: center;
  width: 100%;
  height: 500px; /* Desktop default */
}

.hero-banner::after {
  content: "";
  display: block;
  position: absolute;
  bottom: 0;
  left: 0;
  width: 100%;
  pointer-events: none;
  z-index: 2;
}

/* üì± Mobile-specific fade tuning */
@media (max-width: 767px) {
  .hero-banner::after {
    height: 165px;
    transform: translateY(-110px);
    background: linear-gradient(to bottom, rgba(26, 14, 45, 1), rgba(26, 14, 45, 0));
  }
}

/* üñ• Desktop-specific fade tuning */
@media (min-width: 768px) {
  .hero-banner::after {
    height: 160px;
    transform: translateY(-190px);
    background: linear-gradient(to bottom, rgba(26, 14, 45, 1), rgba(26, 14, 45, 0));
  }
}
    
@media (min-width: 768px) {
  .hero-banner {
    height: 600px; /* Adjust until green line hits bottom on desktop */
  }
}

/* Mobile override (‚â§767px) */
@media (max-width: 767px) {
  .hero-banner {
  width: 100vw;
  height: 480px; /* Adjust if needed */
  background-image: url('banner.png');
  background-size: cover;
  background-position: top center;
  background-repeat: no-repeat;
  margin: 0;
  padding: 0;
  display: block;
}

  body {
    background-image: url('background.png');
    background-size: contain;
    background-repeat: repeat-y;
    background-position: top center;
    
  }
}

@media (max-width: 768px) {
  .about .quote {
    position: relative;
    top: 20px; /* Adjust as needed: -10px, -15px, etc. */
  }
}

@media (max-width: 768px) {
  .bonk-tribute {
    position: relative;
    top: 30px;
  }
}

@media (max-width: 768px) {
  .tokenomics-section {
    background-image: url('background-tokenomics.png');
    background-repeat: no-repeat;
    background-size: cover;
    background-position: bottom center;

    display: flex;
    flex-direction: column;
    align-items: center;          /* Center contents horizontally */
    justify-content: flex-start;  /* Let us control spacing manually */

    padding: 250px 20px 80px;      /* Top, side, bottom */
    min-height: auto;
  }

  .tokenomics-content {
    align-self: stretch;          /* Let it fill width if needed */
    text-align: center;           /* Optional: center content */
    position: relative;
    color: white;
    z-index: 2;
    margin-bottom: 80px;
  }

  .tokenomics-section footer {
    margin-top: 40px;             /* Push footer to the bottom */
    text-align: center;
    color: #fff;
    font-size: 0.9rem;
    padding-bottom: 20px; 
  }

  .tokenomics-section *,
  .lore *,
  .about *,
  .bonk-tribute *,
  .quote,
  footer,
  h1, h2, h3, h4, h5, h6,
  p, li, a, span {
    text-shadow: 0 2px 6px rgba(0, 0, 0, 0.75); /* Still here for contrast */
  }
}

 @media (max-width: 768px) {
  section.section:nth-of-type(4) {
    position: relative;
    top: -20px;
  }
}

 @media (max-width: 768px) {
  /* ‚úÖ BACKDROP BLUR & STYLE FOR KEY SECTIONS */
   .glass-box {
  display: inline-block;                /* Shrink to content size */
  background: rgba(0, 0, 0, 0.25);      /* Subtle dark blur */
  backdrop-filter: blur(4px);          /* Softer blur */
  -webkit-backdrop-filter: blur(4px);  /* Safari support */
  border-radius: 12px;                 /* Slightly rounded */
  padding: 8px 12px;                   /* Minimal padding */
  margin: 10px auto;                   /* Center horizontally */
  box-shadow: 0 0 6px rgba(0, 0, 0, 0.2); /* Light outer glow */
  text-align: center;                  /* Ensure text stays centered */
}

  section.section:nth-of-type(4) {
    position: relative;
    top: -20px;
  }
}

@media screen and (min-width: 768px) {
  body {
    background: 
      url('bottom-banner.png') no-repeat center bottom,
      url('background.png') no-repeat center top;
    background-size: 100% auto, 110%;
    background-repeat: no-repeat, no-repeat;
    background-attachment: scroll, scroll;
    background-color: #1a0e2d;
  }

  .tokenomics-section {
  display: flex;
  flex-direction: column;
  align-items: center; /* ‚úÖ center children horizontally */
  justify-content: flex-start;
  padding-bottom: 40px;
}

  .tokenomics-content {
    max-width: 800px;
    margin: 0 auto;              /* ‚úÖ center horizontally */
    text-align: center;
    color: white;
    position: relative;
    z-index: 2;
    align-self: unset;           /* ‚úÖ removes stretch override */
  } 

  .tokenomics-section footer {
    font-size: 14px;
    margin-top: 60px;
    position: relative;
    z-index: 2;
  }

  html, body {
    height: auto;
    overflow-y: auto;
  }
}

.lore {
  position: relative;
  top: -80px; /* or adjust further as needed */
}

.tokenomics-content ul,
.tokenomics-content li {
  list-style: none;
  margin: 0;
  padding: 0;
}

.tokenomics-content li {
  margin-bottom: 10px;
}

@media (max-width: 768px) {
¬† .jupiter-section {
¬† ¬† margin-top: 80px !important;
¬† }

¬† .memes-section {
¬† ¬† margin-bottom: 40px;
¬† }
}

 @media screen and (min-width: 769px) {
  .degen-toggle-btn,
  .meme-toggle-btn {
    left: 20px !important; 
    right: auto !important;
  }
}

 .console-controls label {
  color: #ffe06b;
  font-weight: bold;
  font-size: 1.1em;
  margin-bottom: 10px;
  display: block;
}

.bottom-fade-divider {
  width: 100%;
  height: 160px; /* same as fade size */
  pointer-events: none;
  position: absolute;
  left: 0;
  z-index: 1;
}

/* Desktop Fade */
@media (min-width: 768px) {
  .bottom-fade-divider {
    background: linear-gradient(to bottom, rgba(26, 14, 45, 0), rgba(26, 14, 45, 1));
    transform: translateY(-1660px); /* adjust upward position */
  }
}

/* Mobile Fade */
@media (max-width: 767px) {
  .bottom-fade-divider {
    background: linear-gradient(to bottom, rgba(26, 14, 45, 0), rgba(26, 14, 45, 1));
    transform: translateY(-155px); /* adjust differently for mobile */
  }
}

 section.memes-section {
  position: relative;
  z-index: 3;
}

.mobile-popup {
  display: none;
  position: fixed;
  z-index: 9999;
  top: 0;
  left: 0;
  right: 0;
  background: rgba(0, 0, 0, 0.9);
  color: white;
  padding: 20px;
  font-size: 16px;
  text-align: center;
}

.popup-content {
  max-width: 400px;
  margin: auto;
}

.mobile-popup button {
  margin-top: 15px;
  padding: 10px 20px;
  background: #00cc99;
  color: white;
  border: none;
  border-radius: 4px;
  font-weight: bold;
  cursor: pointer;
}

 section.bonk-tribute {
  position: relative;
  z-index: 3;
}

@media screen and (max-width: 767px) {
  body.standalone .hero-banner::after {
    transform: translateY(-240px); /* Adjust -10px until it's perfectly aligned */
  }

 body.standalone .bottom-fade-divider {
  transform: translateY(-145px);
 }
}

@media screen and (max-width: 767px) {
 .meme-generator-popup {
  position: fixed;
  top: 10px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 9999;
  background: black;
  color: white;
  border-radius: 12px;
  padding: 16px;
  margin: 0;
  text-align: center;
  max-width: 90%;
  box-shadow: 0 0 12px rgba(0, 0, 0, 0.3);
  pointer-events: auto;
  
}

.meme-generator-popup.hidden {
  display: none !important;
}

.meme-generator-popup .button-container {
  text-align: center;
  margin-top: 15px;
}

.meme-generator-popup button {
  background: #00ff99;
  color: black;
  border: none;
  border-radius: 8px;
  padding: 8px 16px;
  font-weight: bold;
 }
}

@media (max-width: 768px) {
  #memeModal.modal.active {
    display: flex !important;
    flex-direction: column;
    justify-content: flex-start;
    align-items: center;
    padding: 10px 10px 30px;
    overflow-y: auto;
    max-height: 100vh;
  }

  .console-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 20px;
    padding-bottom: 24px;
    box-sizing: border-box;
    overflow-y: auto;
    max-height: unset;
    touch-action: manipulation;
  }

  .console-controls {
    width: 100%;
    max-width: 360px;
    padding: 0 10px;
    order: 1;
    z-index: 2;
  }

  .console-canvas {
    order: 2;
    margin-top: -10px;
    z-index: 1;
  }

  #memeCanvas {
    width: 100%;
    max-width: 95%;
    height: auto;
    margin: 12px auto 20px;
    display: block;
    border: 2px dashed white;
    box-sizing: border-box;
    touch-action: none;
  }

  .console-controls input,
  .console-controls select,
  .console-controls button {
    font-size: 1em;
    padding: 10px;
    border-radius: 8px;
    border: none;
    font-weight: bold;
    touch-action: manipulation;
    pointer-events: auto !important;
  }

  .button-row {
    display: flex;
    flex-direction: column;
    gap: 10px;
    width: 100%;
    margin-top: 10px;
  }

  .button-row button {
    width: 100%;
    padding: 12px;
    border-radius: 10px;
    background: linear-gradient(135deg, #ff4fd8 0%, #ffe06b 100%);
    color: #000;
    font-weight: bold;
    border: none;
  }
}

 @media (min-width: 768px) {
  #memeGeneratorPopup {
    display: none !important;
  }
}

/* -------------------------------
   Desktop Easter Egg Buttons
-------------------------------- */
@media (min-width: 768px) {
  .easter-egg {
    position: fixed;
    top: 50%;
    width: 120px;
    height: 120px;
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    z-index: 9999;
    cursor: pointer;
    transform: translateY(-50%);
  }

  .meme-boost {
    left: 120px;
    background-image: url('circle.png');
  }

  .read-lore {
    right: 120px;
    background-image: url('lore.png');
}

/* -------------------------------
   Meme Boost Popup Styles
-------------------------------- */
.popup {
  position: fixed;
  top: 80px;
  left: 50%;
  transform: translateX(-50%);
  background: black;
  color: white;
  padding: 20px;
  border-radius: 12px;
  z-index: 9999;
  text-align: center;
  max-width: 90%;
  box-shadow: 0 0 12px rgba(0, 0, 0, 0.3);
}
.popup.hidden {
  display: none !important;
}
.popup-content button {
  background: #00ff99;
  color: black;
  border: none;
  border-radius: 8px;
  padding: 8px 16px;
  margin-top: 15px;
  font-weight: bold;
  cursor: pointer;
}

/* -------------------------------
   Lore Popup Styles
-------------------------------- */
.read-lore-popup {
  position: fixed;
  top: 80px;
  left: 50%;
  transform: translateX(-50%);
  background: black;
  color: white;
  padding: 20px;
  border-radius: 12px;
  z-index: 9999;
  text-align: center;
  max-width: 90%;
  box-shadow: 0 0 12px rgba(0, 0, 0, 0.3);
}
.read-lore-popup.hidden {
  display: none !important;
}
.read-lore-popup button {
  background: #00ff99;
  color: black;
  border: none;
  border-radius: 8px;
  padding: 8px 16px;
  margin-top: 15px;
  font-weight: bold;
  cursor: pointer;
 }
}

 @media (max-width: 768px) {
  #memeBoostPopup:not(.hidden),
  #lorePopup:not(.hidden) {
    display: none !important;
  }
}

/* üåê Solana Icon Launcher */
.solana-icon-launcher {
  position: absolute;
  top: 440px;
  left: 20px;
  z-index: 999;
  cursor: pointer;
}

.solana-icon-launcher img {
  width: 48px;
  height: 48px;
  transition: transform 0.3s ease;
}

.solana-icon-launcher img:hover {
  transform: scale(1.1);
}

/* üß† Dev Terminal Modal */
#solanaDevModal .solana-dev-content {
  background: #1e1e1e;
  padding: 20px;
  border-radius: 12px;
  max-width: 500px;
  width: 90%;
  text-align: center;
  color: #fff;
  font-family: monospace;
  box-shadow: 0 0 18px rgba(0,255,200,0.3);
}

#solanaDevModal input {
  padding: 10px;
  border-radius: 6px;
  width: 100%;
  margin-top: 10px;
  font-family: monospace;
  border: none;
}

#solanaDevModal button {
  background: #00ffa1;
  color: #000;
  border: none;
  padding: 10px 16px;
  font-weight: bold;
  border-radius: 6px;
  margin-top: 10px;
  cursor: pointer;
}

.terminal-box {
  text-align: left;
  background: #000;
  padding: 10px;
  margin: 10px 0;
  height: 150px;
  overflow-y: auto;
  border-radius: 8px;
  font-size: 0.9em;
  white-space: pre-wrap;
  color: #00ffcc;
  box-shadow: inset 0 0 10px #00ffc3;
}

/* üì± Mobile Adjustments */
@media (max-width: 768px) {
  .solana-icon-launcher {
    top: 360px;
    left: 10px;
  }

  #solanaDevModal .solana-dev-content {
    font-size: 0.9em;
    padding: 16px;
  }

  .terminal-box {
    font-size: 0.8em;
    height: 120px;
  }
}

  </style>

<script>
  // ‚úÖ Clean SPL UMD loader with Promise support
  window.splTokenReady = new Promise((resolve, reject) => {
    const script = document.createElement("script");
    script.src = "https://cdn.jsdelivr.net/npm/@solana/spl-token@0.1.8/lib/index.iife.js";

    script.onload = () => {
      if (typeof splToken !== "undefined") {
        window.splToken = splToken;
        console.log("‚úÖ SPL Token UMD loaded via v0.1.8");
        resolve();
      } else {
        reject(new Error("‚ùå splToken global not found"));
      }
    };

    script.onerror = () => reject(new Error("‚ùå Failed to load SPL Token script"));

    document.head.appendChild(script);
  });
</script>
 
  <script src="https://terminal.jup.ag/main-v4.js"></script>
  
 </head>
 
 <body>

<header class="hero-banner"></header>
  
<div class="body-background-fade"></div>

<div class="coin-fall" id="coin-fall"></div>

<section class="section about">
  <h2>üöÄ About</h2>
 <div class="glass-box">
  <p>$WAGMIK is the coin for every Solana degen who bought the top, paper-handed the bottom, and still thinks memes are a valid investment strategy.
  </p>
   </div>
  <div class="quote">
    ‚ÄúThis coin has no utility, and that‚Äôs the utility.‚Äù<br>
    <span>‚Äì A true degen prophet</span>
  </div>
  <a href="https://letsbonk.fun" target="_blank" class="cta">Buy on Bonk Launchpad</a>
</section>

<section class="floating-lore-wrapper">
  <div class="floating-lore">
    <div class="lore-chapter">In the deep shadows of Solana memecoin culture...</div>
    <div class="lore-chapter">While BONK soared to memetic greatness, $WAGMIK sat quietly in the trenches...</div>
    <div class="lore-chapter">He wasn‚Äôt the fastest dog. He wasn‚Äôt airdropped to influencers...</div>
    <div class="lore-chapter">He was BONK‚Äôs underdog cousin...</div>
    <div class="lore-chapter">But instead of giving up, he asked ChatGPT for advice...</div>
    <div class="lore-chapter">Born from regret and refined by copium, $WAGMIK clawed into existence...</div>
    <div class="lore-chapter">Now, $WAGMIK isn‚Äôt here to change the world...</div>
    <div class="lore-chapter">He‚Äôs not just a token. He‚Äôs a story. A meme. A movement.</div>
  </div>
</section>

<section class="section lore">
  <h2>üß¨ Lore</h2>
    <div class="glass-box">
  <p>Forged from chart tears and bottom buys, $WAGMIK was born in the depths of Solana Twitter and raised on hopium. Bonk was the cousin who made it. WAGMIK was left behind. Until now.</p>
      </div>
</section>

<section class="section bonk-tribute">
  <h2>üî• The Bonk Tribute</h2>
  <iframe
    src="https://dexscreener.com/solana/ysq96dvzrrmvrassyb2vr5chfwosqdrzqrgnmrrtr1l"
    frameborder="0"
    style="width:100%; height:500px; border:none; border-radius:12px;"
    allowfullscreen
  ></iframe>
</section>

<!-- üöÄ Meme Gallery Section -->
<section class="section memes-section" id="meme-gallery">
  <h2>üòÇ Community Memes</h2>
  <div class="gallery-wrapper">
    <div class="gallery-track" id="memeTrack">
      <!-- REPLACE src with your meme file paths -->
      <img src="meme1.png" alt="Meme 1" class="gallery-meme" />
      <img src="meme2.png" alt="Meme 2" class="gallery-meme" />
      <img src="meme3.png" alt="Meme 3" class="gallery-meme" />
      <img src="meme4.png" alt="Meme 4" class="gallery-meme" />
      <img src="meme5.png" alt="Meme 5" class="gallery-meme" />
      <img src="meme6.png" alt="Meme 6" class="gallery-meme" />
      <img src="meme7.png" alt="Meme 7" class="gallery-meme" />
      <img src="meme8.png" alt="Meme 8" class="gallery-meme" />
      <img src="meme9.png" alt="Meme 9" class="gallery-meme" />
      <img src="meme10.png" alt="Meme 10" class="gallery-meme" />
      <img src="meme11.png" alt="Meme 11" class="gallery-meme" />
      <img src="meme12.png" alt="Meme 12" class="gallery-meme" />
      <!-- Add as many as needed -->
    </div>
  </div>

   <!-- Lightbox -->
  <div id="lightbox" class="lightbox">
    <img src="" alt="Zoomed Meme" id="lightbox-img" />
  </div>
</section>

<!-- Jupiter Swap Section -->
<section class="section jupiter-section">
¬† <h2>üõí Use Jupiter to Buy $WAGMIK</h2>
¬† <div id="jupiter-terminal"></div>
</section>

<!-- Bottom Fade Divider -->
<div class="bottom-fade-divider"></div>
 
<section class="tokenomics-section">
  <div class="tokenomics-content glass-box">
    <ul>
      <li><strong>Total Supply:</strong> 1,000,000,000</li>
      <li><strong>Tax:</strong> 0%</li>
      <li><strong>Chain:</strong> Solana</li>
      <li><strong>Utility:</strong> Vibes, Lore & Copium</li>
    </ul>
  </div>
   <footer>
   Made with memes, madness, and moon math ‚ú®
   <br/>
   ¬© 2025 $WAGMIK. No rights reserved.
  </footer>
</section>


<!-- Lore Button & Modal -->
<button class="floating-button lore-toggle-btn" onclick="toggleLore()">üìú Read Lore</button>
<div class="modal" id="loreModal">
  <button class="close-btn" onclick="toggleLore()">‚úñ</button>
  <div class="lore-chapter">In the deep shadows of Solana memecoin culture...</div>
  <div class="lore-chapter">While BONK soared to memetic greatness, $WAGMIK sat quietly in the trenches...</div>
  <div class="lore-chapter">He wasn‚Äôt the fastest dog. He wasn‚Äôt airdropped to influencers...</div>
  <div class="lore-chapter">He was BONK‚Äôs underdog cousin...</div>
  <div class="lore-chapter">But instead of giving up, he asked ChatGPT for advice...</div>
  <div class="lore-chapter">Born from regret and refined by copium, $WAGMIK clawed into existence...</div>
  <div class="lore-chapter">Now, $WAGMIK isn‚Äôt here to change the world...</div>
  <div class="lore-chapter">He‚Äôs not just a token. He‚Äôs a story. A meme. A movement.</div>
</div>

<!-- Degen Button & Modal -->
<button class="floating-button degen-toggle-btn" onclick="toggleDegen()">üß† Degen Mode</button>
<div class="modal" id="degenModal">
  <button class="close-btn" onclick="toggleDegen()">‚úñ</button>
  <h2>Degen Prophecies by $WAGMIK</h2>
  <p id="degenProphecy">Loading prophecy...</p>
</div>

   <!-- Meme Generator Button & Modal -->
<button class="floating-button meme-toggle-btn" onclick="toggleMeme()">üé≠ Meme Generator</button>

<div class="modal" id="memeModal">
  <button class="close-btn" onclick="toggleMeme()">‚úñ</button>

   <!-- Meme Generator Popup -->
  <div id="memeGeneratorPopup" class="meme-generator-popup">
    <div class="modal-content">
      <h2>üî• Welcome!</h2>
      <p style="margin-top: 10px;">
        For the best experience, tap <strong>Share</strong> ‚Üí <strong>Add to Home Screen</strong> to use this as an app.
      </p>
      <div class="button-container">
        <button onclick="dismissMemePopup()">Got it!</button>
      </div>
    </div>
  </div>

 <!-- Meme Boost Popup -->
<div id="memeBoostPopup" class="popup hidden">
  <div class="popup-content">
    <h2>üöÄ Meme Boost Activated!</h2>
    <p>You've just been blessed with a premium meme preset.</p>
    <button onclick="dismissMemeBoostPopup()">Got it!</button>
  </div>
</div>

<div id="lorePopup" class="read-lore-popup hidden">
  <h2>üìú Lore Drop!</h2>
  <p style="margin-top: 10px;">You're now tapped into the sacred $WAGMIK scrolls of prophecy...<br>
  <strong id="randomLoreText"></strong>
  </p>
  <div class="button-container">
    <button onclick="dismissLorePopup()">Got it!</button>
  </div>
</div>

<!-- Floating Easter Eggs (desktop only) -->
<div id="memeBoostBtn" class="easter-egg meme-boost" title="Meme Boost"></div>
<div id="readLoreBtn" class="easter-egg read-lore" title="Read Lore"></div>

   <div class="console-container">
    <img src="console-layout.png" class="console-bg" alt="MEME Generator">
  </div>

    <!-- üéõ Controls Section -->
    <div class="console-controls">
      <label>MEME Generator</label>

      <select id="bgSelect">
        <option value="">None</option>
        <option value="bg-trading.png">Trading Setup</option>
        <option value="bg-luxury.png">Luxury Lifestyle</option>
        <option value="bg-degen.png">Degen House</option>
        <option value="casino.png">Casino</option>
        <option value="jet.png">Jet</option>
        <option value="Liberty.png">Liberty Statue</option>
        <option value="GTA 6.png">GTA 6</option>
        <option value="dubai.png">Dubai</option>
        <option value="Office.png">Office</option>
        <option value="elon-meme.png">Elon</option>
      </select>

      <select id="hatSelect">
        <option value="">None</option>
        <option value="wagmik-hat.png">Wagmik Hat</option>
        <option value="wagmik-logo-hat.png">Wagmik Logo Hat</option>
        <option value="WAGMIK-mask.png">Wagmik Mask</option>
        <option value="meme-hat.png">MEME Hat</option>
        <option value="wif-hat.png">WIF Hat</option>
        <option value="bonk-mask.png">Bonk Mask</option>
        <option value="degen-hat.png">DEGEN Hat</option>
        <option value="degen-hat2.png">DEGEN Hat2</option>
        <option value="pepe-hat.png">Pepe Hat</option>
        <option value="pepe-mask.png">Pepe Mask</option>
        <option value="tom-mask.png">Tom Mask</option>
        <option value="ssj.png">SSJ Hair</option>
        <option value="ssj-blue.png">SSJ Blue Hair</option>
      </select>

      <select id="chainSelect">
        <option value="">None</option>
        <option value="bitcoin.png">Bitcoin</option>
        <option value="chain2.png">Cuban Chain</option>
        <option value="glasses.png">Meme Glasses</option>
        <option value="dollar-glasses.png">Dollar Glasses</option>
        <option value="lightsaber.png">Lightsaber</option>
        <option value="katana.png">Katana</option>
        <option value="god-candle.png">God Candle</option>
        <option value="bro-look.png">Bro Look</option>
        <option value="buy-sign.png">Buy Sign</option>
        <option value="cigarette.png">Cigarette</option>
        <option value="wojak.png">Wojak</option>
        <option value="wojak-mystery.png">Wojak 2</option>
        <option value="wojak-boomer.png">Wojak Boomer</option>
      </select>

      <select id="characterSelect">
        <option value="">None</option>
        <option value="ansem.png">Ansem</option>
        <option value="bonk-pengu.png">Bonk Pengu</option>
        <option value="bossman.png">Bossman</option>
        <option value="bren.png">Bren</option>
        <option value="caleb.png">Caleb</option>
        <option value="DJ.png">DJ</option>
        <option value="fomo.png">Fomo</option>
        <option value="hopium-papi.png">Hopium Papi</option>
        <option value="iced.png">Iced</option>
        <option value="mert.png">Mert</option>
        <option value="solana-sensei.png">Solana Sensei</option>
        <option value="sugar.png">Sugar</option>
        <option value="wolf.png">Wolf</option>
        <option value="wolf-rich.png">Wolf Rich</option>
        <option value="ponke.png">Ponke</option>
        <option value="pepe.png">Pepe</option>
        <option value="goku-ui.png">Goku UI</option>
        <option value="saitama.png">Saitama</option>
        <option value="wagmik-cheering.png">Wagmik Cheering</option>
        <option value="wagmik-bullish.png">Wagmik</option>
        <option value="wagmik-look.png">Wagmik2</option>
        <option value="wagmik-onedollar.png">Wagmik3</option>
        <option value="wagmik-give.png">Wagmik4</option>
      </select>

     <input autocapitalize="off" autocomplete="off" id="topText" inputmode="text" placeholder="Top Text" tabindex="0" type="text"/>
     <input autocapitalize="off" autocomplete="off" id="bottomText" inputmode="text" placeholder="Bottom Text" tabindex="0" type="text"/>

      <!-- üß† Stylish Buttons -->
      <div class="button-row">
        <button onclick="drawMeme()" class="console-btn">Preview</button>
        <button id="downloadOrMintBtn">Download or Mint</button>
        <button onclick="resetMeme()" class="console-btn full-width">Reset</button>
        <button id="shareBtn">Share on X</button>
      </div>
    </div>
   
    <!-- üñº Preview Canvas -->
    <canvas id="memeCanvas" class="console-canvas" width="360" height="360"></canvas>

    <!-- üîÅ Rotation Slider -->
    <div id="rotationSliderWrapper" style="display:none; margin-top: 10px;">
      <label style="color: white;">Rotate</label>
      <input id="rotationSlider" type="range" min="-180" max="180" value="0" />
      <button id="deleteBtn" style="margin-top: 8px;">üóë Delete</button>
    </div>
  </div>
</div>

<div id="downloadMintPopup" class="popup hidden">
  <div class="popup-content">
    <h2>What do you want to do?</h2>
    <button id="popupDownloadBtn">üì• Download</button>
    <button id="popupMintBtn">ü™ô Mint NFT</button>
    <button id="popupCloseBtn">Cancel</button>
  </div>
</div>

 <!-- üì¢ Share Rules Modal -->
<div id="shareModal" class="share-modal hidden">
¬† <div class="modal-content">
¬† ¬† <h2>üìú Meme Sharing Rules</h2>
¬† ¬† <ul>
¬† ¬† ¬† <li>‚úÖ Tag <strong>@wagmikdotsol</strong></li>
¬† ¬† ¬† <li>‚úÖ Follow the official account</li>
¬† ¬† ¬† <li>‚úÖ Use the meme generator</li>
¬† ¬† ¬† <li>‚úÖ Verified X accounts only</li>
¬† ¬† ¬† <li>üìå Upload the meme you downloaded</li>
¬† ¬† </ul>
¬† ¬† <p style="margin-top: 20px;">
¬† ¬† ¬† üöÄ Press <strong>Continue</strong> to go to X and post your meme.
¬† ¬† ¬† <br />
¬† ¬† ¬† üß† Don‚Äôt forget to <strong>attach your image</strong>!
¬† ¬† </p>
¬† ¬† <div class="button-container">
¬† ¬† ¬† <button id="confirmShare">Continue to X</button>
¬† ¬† ¬† <button id="cancelShare">Cancel</button>
¬† ¬† </div>
¬† </div>
</div>

<!-- üåê Floating App Links (Left Center) -->
<div class="floating-apps">
 <!-- Solana App Icon for Developer Terminal -->
<a id="solanaAppIcon">
  <img src="solana.png" alt="Solana Dev" class="app-logo" />
</a>
 <a href="https://x.com/WAGMIKdotSOL" target="_blank">
    <img src="x_image.png" alt="Twitter X" class="app-logo" />
  </a>
  <a href="https://bullx.io/login?redirectUrl=" target="_blank">
    <img src="bullx.png" alt="BullX" class="app-logo" />
  </a>
  <a href="https://axiom.trade/" target="_blank">
    <img src="axiom.png" alt="Axiom" class="app-logo" />
  </a>
  <a href="https://photon-sol.tinyastro.io/" target="_blank">
    <img src="photon.png" alt="Photon" class="app-logo" />
  </a>
</div>

<!-- üîß Solana Dev Terminal Modal -->
<div class="modal" id="solanaDevModal">
  <button class="close-btn" onclick="document.getElementById('solanaDevModal').classList.remove('active')">‚úñ</button>

  <div class="solana-dev-content">
    <h2>üõ† WAGMIK Dev Terminal</h2>
    <p>Connect your wallet. Deploy vibes. Meme responsibly.</p>

    <button id="connectWalletBtn">üîå Connect Wallet</button>
    <p id="walletAddressDisplay">Wallet not connected</p>

   <button id="disconnectWalletBtn" style="margin-top: 8px;">üö™ Disconnect</button>

   <button onclick="createCollection()">Create WAGMIK Meme Collection</button>

<div id="terminalOutput" class="terminal-box" style="white-space: pre-wrap;">
  <p style="margin: 0 0 4px;">Welcome to the $WAGMIK Solana Console üíÄ</p>
  <div style="margin: 0 0 2px; font-size: 0.95em;">
    <strong style="margin: 0 0 2px; display: inline-block;">Available Commands:</strong>
    <ul id="commandList" style="padding-left: 16px; margin: 0; color: #00ffa1; list-style: disc; line-height: 1.3; font-family: monospace;">
  <li style="margin: 0;"><code>balance</code> ‚Äî check wallet SOL</li>
  <li style="margin: 0;"><code>send &lt;recipient&gt; &lt;amount&gt;</code> ‚Äî transfer SOL</li>
  <li style="margin: 0;"><code>spltokens</code> ‚Äî list SPL token balances</li>
  <li style="margin: 0;"><code>splsend &lt;mint&gt; &lt;recipient&gt; &lt;amount&gt;</code> ‚Äî send SPL tokens</li>
  <li style="margin: 0;"><code>dappcheck</code> ‚Äî check Solana dApp readiness</li>
  <li style="margin: 0;"><code>view nft</code></li>
</ul>
  </div>
</div>

   <label for="clusterSelect" style="margin-top: 12px; color: #00ffa1;">Network:</label>
<select id="clusterSelect" style="margin-bottom: 10px;">
  <option value="devnet" selected>Devnet</option>
  <option value="mainnet-beta">Mainnet</option>
  <option value="localhost">Localhost</option>
</select>

    <input id="terminalInput" type="text" placeholder="> Enter command" />
    <button id="runCommandBtn">Run</button>
  </div>
</div>

<div id="nftGalleryPopup" class="popup hidden">
  <div class="popup-content">
    <h2>üé® Your NFTs</h2>
    <div id="nftGalleryContent" style="display: flex; flex-wrap: wrap; gap: 12px; justify-content: center;"></div>
    <button onclick="document.getElementById('nftGalleryPopup').classList.add('hidden')">Close</button>
  </div>
</div>

  
  <script>
   function createCoin() {
    const coin = document.createElement("div");
    coin.classList.add("coin");
    coin.style.left = Math.random() * 100 + "vw";
    coin.style.animationDuration = (Math.random() * 3 + 3) + "s";
    document.getElementById("coin-fall").appendChild(coin);
    setTimeout(() => coin.remove(), 7000);
  }
  setInterval(createCoin, 400);
  </script>
  
  <script>
   // Lightbox Logic
  const lightbox = document.getElementById("lightbox");
  const lightboxImg = document.getElementById("lightbox-img");
  const memes = document.querySelectorAll(".gallery-meme");

  memes.forEach((meme) => {
    meme.addEventListener("click", () => {
      lightboxImg.src = meme.src;
      lightbox.style.display = "flex";
    });
  });

  lightbox.addEventListener("click", () => {
    lightbox.style.display = "none";
  });
  </script>
  <script>
   const chapters = document.querySelectorAll('.lore-chapter');

  window.addEventListener('scroll', () => {
    const scrollY = window.scrollY;

    chapters.forEach((chapter, index) => {
      // Reveal each chapter after a certain scroll depth
      const triggerPoint = 200 + index * 150;

      if (scrollY > triggerPoint) {
        chapter.classList.add('visible');
      } else {
        chapter.classList.remove('visible');
      }
    });
  });
  </script>

<script>
  // üîÅ Toggle Meme Modal
  function toggleMeme() {
    const memeModal = document.getElementById('memeModal');
    const popup = document.getElementById('memeGeneratorPopup');

    const loreBtn = document.querySelector('.lore-toggle-btn');
    const degenBtn = document.querySelector('.degen-toggle-btn');
    const memeBtn = document.querySelector('.meme-toggle-btn');

    memeModal.classList.toggle('active');

    // ‚úÖ Show popup on mobile only
    const isMobile = /Mobi|Android/i.test(navigator.userAgent);
    const isStandalone = window.matchMedia('(display-mode: standalone)').matches;

    if (window.innerWidth < 768 && isMobile && !isStandalone && memeModal.classList.contains('active')) {
      popup?.classList.remove("hidden");
    } else {
      popup?.classList.add("hidden");
    }

    if (window.innerWidth < 768) {
      const isActive = memeModal.classList.contains('active');
      const visibility = isActive ? 'hidden' : 'visible';

      if (loreBtn) loreBtn.style.visibility = visibility;
      if (degenBtn) degenBtn.style.visibility = visibility;
      if (memeBtn) memeBtn.style.visibility = visibility;

      document.body.style.overflow = isActive ? 'hidden' : '';
    }
  }

  // üîÅ Toggle Lore Modal
  function toggleLore() {
    const modal = document.getElementById('loreModal');
    modal.classList.toggle('active');

    if (window.innerWidth < 768 && modal.classList.contains('active')) {
      modal.focus();
    }
  }

  // üîÅ Toggle Degen Modal
  function toggleDegen() {
    const modal = document.getElementById('degenModal');
    const lines = [
      "Buy high, hold higher.",
      "You only lose when you sell.",
      "Gas fees are a state of mind.",
      "If it dumps, double down.",
      "Degen rule #88: Never check the chart.",
      "Real utility is in the meme.",
      "WAGMIK is a vibe, not a roadmap.",
      "Coins come and go, but hopium is eternal.",
      "He who panics last, panics best.",
      "Trust the vibes, not the volume."
    ];

    if (!modal.classList.contains('active')) {
      document.getElementById('degenProphecy').textContent =
        `"${lines[Math.floor(Math.random() * lines.length)]}"`;
    }

    modal.classList.toggle('active');

    if (window.innerWidth < 768 && modal.classList.contains('active')) {
      modal.focus();
    }
  }

  // --------------------------
  // ‚ùå Dismiss Functions
  // --------------------------
  function dismissMemePopup() {
    const popup = document.getElementById('memeGeneratorPopup');
    if (popup) popup.classList.add("hidden");
  }

  function dismissMemeBoostPopup() {
    const popup = document.getElementById('memeBoostPopup');
    if (popup) popup.classList.add("hidden");
  }

  function dismissLorePopup() {
    const popup = document.getElementById('lorePopup');
    if (popup) popup.classList.add("hidden");
  }

  // --------------------------
  // üöÄ Handle Meme Boost
  // --------------------------
  document.getElementById("memeBoostBtn")?.addEventListener("click", function () {
    document.getElementById("memeBoostPopup").classList.remove("hidden");

    const memeImages = [
      "memeboost1.png",
      "memeboost2.png",
      "memeboost4.png",
      "memeboost5.png",
      "memeboost6.png"
    ];

    const randomImage = memeImages[Math.floor(Math.random() * memeImages.length)];

    const canvas = document.getElementById("memeCanvas");
    const ctx = canvas.getContext("2d");

    const img = new Image();
    img.src = randomImage;

    img.onload = function () {
      canvas.width = img.width;
      canvas.height = img.height;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(img, 0, 0);
    };
  });

  // --------------------------
  // üìú Handle Lore Click
  // --------------------------
  document.getElementById("readLoreBtn")?.addEventListener("click", function () {
    document.getElementById("lorePopup").classList.remove("hidden");
    showRandomLore();
  });

  // --------------------------
  // üîÆ Generate Random Lore Text
  // --------------------------
  function showRandomLore() {
    const lores = [
      "Degen prophecy #23: Buy the top, post the meme.",
      "Only the chosen few escape the rug.",
      "The chart fell, but the meme lived.",
      "WAGMIK scrolls: Buy, cope, meme, repeat."
    ];

    const random = lores[Math.floor(Math.random() * lores.length)];
    const loreTextElement = document.getElementById("randomLoreText");

    if (loreTextElement) {
      loreTextElement.textContent = random;
    }
  }
</script>
  
<script>
  async function getMobileWallet() {
    const isMobile = window.innerWidth <= 768;

    // Phantom
    if (isMobile && window.solana?.isPhantom) {
      try {
        await window.solana.connect();
        return window.solana;
      } catch (err) {
        console.warn("Phantom connection declined.");
      }
    }

    // Backpack
    if (isMobile && window.backpack?.solana?.connect) {
      try {
        await window.backpack.solana.connect();
        return window.backpack.solana;
      } catch (err) {
        console.warn("Backpack connection declined.");
      }
    }

    return null;
  }
</script>

<script>
  getMobileWallet().then(wallet => {
    window.Jupiter.init({
      displayMode: "integrated",
      integratedTargetId: "jupiter-terminal",
      endpoint: "https://api.mainnet-beta.solana.com",
      wallet: wallet, // ‚Üê ‚úÖ inject wallet if available
      formProps: {
        fixedOutputMint: "EPjFWdd5AufqSSqeM2qN1xzxybapC8G4wEGGkZwyTDt1", // USDC
        initialAmount: "1"
      },
      containerStyles: {
        width: "100%",
        maxWidth: "400px",
        margin: "0 auto",
        borderRadius: "12px",
        boxShadow: "0 0 12px rgba(0,0,0,0.3)",
        overflow: "hidden"
      }
    });
  });
</script>


<script>

// --- Canvas Setup ---
const canvas = document.getElementById('memeCanvas');
const ctx = canvas.getContext('2d');

const tiers = [
  { value: "WAGMIK GOLD", weight: 1 },
  { value: "Diamond Hands", weight: 4 },
  { value: "Premium", weight: 5 },
  { value: "Ultimate", weight: 10 },
  { value: "Silver", weight: 20 },
  { value: "Common", weight: 60 }
];

function getRandomTier() {
  const total = tiers.reduce((sum, t) => sum + t.weight, 0);
  const rand = Math.random() * total;
  let cumulative = 0;
  for (let t of tiers) {
    cumulative += t.weight;
    if (rand < cumulative) return t.value;
  }
}

// Only block gestures if touches are inside canvas bounds
function shouldBlockCanvasGesture(e) {
¬† const rect = canvas.getBoundingClientRect();
¬† const x = e.touches[0]?.clientX;
¬† const y = e.touches[0]?.clientY;
¬† return (
¬† ¬† x >= rect.left &&
¬† ¬† x <= rect.right &&
¬† ¬† y >= rect.top &&
¬† ¬† y <= rect.bottom
¬† );
}

// ‚úÖ Attach listeners to canvas touch events
["touchstart", "touchmove", "touchend"].forEach(eventType => {
¬† canvas.addEventListener(eventType, (e) => {
¬† ¬† if (shouldBlockCanvasGesture(e)) {
¬† ¬† ¬† e.preventDefault(); // ‚õî prevent browser from hijacking gesture
¬† ¬† }
¬† }, { passive: false });
});

const bgSelect = document.getElementById('bgSelect');
const hatSelect = document.getElementById('hatSelect');
const chainSelect = document.getElementById('chainSelect');
const characterSelect = document.getElementById('characterSelect');
const topTextInput = document.getElementById('topText');
const bottomTextInput = document.getElementById('bottomText');

const rotationSlider = document.getElementById("rotationSlider");
const sliderWrapper = document.getElementById("rotationSliderWrapper");

let selectedObj = null;
let activeTouchObj = null;
let lockedObj = null;
let selectedTouchTarget = null;
let canvasMouseDown, canvasMouseMove, canvasMouseUp, canvasWheel;
let initialDist = 0;
let initialAngle = 0;
let initialScale = 1;
let initialRotation = 0;

const hats = [];
const chains = [];
const characters = [];

const backgrounds = {
  "bg-trading.png": new Image(),
  "bg-luxury.png": new Image(),
  "bg-degen.png": new Image(),
  "casino.png": new Image(),
  "jet.png": new Image(),
  "Liberty.png": new Image(),
  "GTA 6.png": new Image(),
  "dubai.png": new Image(),
  "Office.png": new Image(),
  "elon-meme.png": new Image()
};

Object.keys(backgrounds).forEach(key => backgrounds[key].src = key);

rotationSlider.addEventListener("input", () => {
  if (selectedObj) {
    selectedObj.rotation = parseFloat(rotationSlider.value) * Math.PI / 180;
    drawCanvas();
  }
});

document.getElementById('deleteBtn').addEventListener('click', deleteSelectedObject);

function drawMeme() {
¬† const hatVal = hatSelect.value;
¬† const chainVal = chainSelect.value;
¬† const charVal = characterSelect.value;

¬† if (hatVal && !hats.some(obj => obj.img.src.includes(hatVal))) {
¬† ¬† createAccessory('hat', hatVal, 0.6);
¬† }

¬† if (chainVal && !chains.some(obj => obj.img.src.includes(chainVal))) {
¬† ¬† createAccessory('chain', chainVal, 0.7);
¬† }

¬† if (charVal && !characters.some(obj => obj.img.src.includes(charVal))) {
¬† ¬† createAccessory('character', charVal, 1.1);
¬† }
}

 function createAccessory(type, imgSrc, scale) {
  const defaultScales = {
    character: 0.6,
    hat: 0.45,
    chain: 0.4
  };
  scale = scale ?? defaultScales[type] ?? 1.0;

  const targetArray = type === 'hat' ? hats : type === 'chain' ? chains : characters;
  if (targetArray.some(obj => obj.img.src === imgSrc)) return;

  const img = new Image();
  img.src = imgSrc;

  const obj = {
    role: type,
    img,
    x: 0,
    y: 0,
    scale,
    rotation: 0,
    dragging: false,
    gestureActive: false,
    offsetX: 0,
    offsetY: 0,
    initialScale: scale,
    initialRotation: 0,
  };

  targetArray.push(obj);

 img.onload = () => {
const maxX = canvas.width - (img.width * obj.scale);
const maxY = canvas.height - (img.height * obj.scale);

let x = (canvas.width - img.width * obj.scale) / 2;
let y = (canvas.height - img.height * obj.scale) / 2;

if (type === 'hat') y -= 40;
if (type === 'chain') y += 50;
if (type === 'character') y -= 20;

const centerX = canvas.width / 2;
const centerY = canvas.height / 2;

obj.x = Math.max(0, Math.min(centerX - (img.width * obj.scale) / 2, maxX));
obj.y = Math.max(0, Math.min(centerY - (img.height * obj.scale) / 2, maxY));

  setupDragAndResize(obj);
  setupTouchHandlers(obj);
  drawCanvas();
 };
}

function drawCanvas() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Draw background
  const bg = backgrounds[bgSelect.value];
  if (bg && bg.complete) {
    ctx.drawImage(bg, 0, 0, canvas.width, canvas.height);
  }

  // ‚úÖ Correct layer order: character first, then accessories
  const allObjects = [...characters, ...hats, ...chains];

  allObjects.forEach(obj => {
    if (!obj.img || !obj.img.src) return;

    const w = obj.img.width * obj.scale;
    const h = obj.img.height * obj.scale;

    ctx.save();
    ctx.translate(obj.x + w / 2, obj.y + h / 2);
    ctx.rotate(obj.rotation);
    ctx.drawImage(obj.img, -w / 2, -h / 2, w, h);

if (window.innerWidth < 768 && obj === activeTouchObj) {
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
    ctx.lineWidth = 2;
    ctx.setLineDash([6, 4]);
    ctx.strokeRect(-w / 2, -h / 2, w, h);
    ctx.setLineDash([]);

    const btnSize = 24;
    const btnX = -w / 2 - btnSize / 2;
    const btnY = -h / 2 - btnSize / 2;

    ctx.fillStyle = 'red';
    ctx.beginPath();
    ctx.arc(btnX + btnSize / 2, btnY + btnSize / 2, btnSize / 2, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = 'white';
    ctx.font = '16px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('‚úï', btnX + btnSize / 2, btnY + btnSize / 2);

    const cos = Math.cos(obj.rotation);
    const sin = Math.sin(obj.rotation);
    const centerX = obj.x + (obj.img.width * obj.scale) / 2;
    const centerY = obj.y + (obj.img.height * obj.scale) / 2;

    const btnCenterX = centerX + (btnX * cos - btnY * sin);
    const btnCenterY = centerY + (btnX * sin + btnY * cos);

    obj.deleteBtnBounds = {
      x: btnCenterX - btnSize / 2,
      y: btnCenterY - btnSize / 2,
      size: btnSize,
      centerX: btnCenterX,
      centerY: btnCenterY
    };
  }

  if (window.innerWidth >= 768) {
    delete obj.deleteBtnBounds;
  }

    ctx.restore();
  });

  ctx.textBaseline = 'top'; // add this
  ctx.font = '28px Impact, sans-serif';
  ctx.textAlign = 'center';
  ctx.fillStyle = 'white';
  ctx.strokeStyle = 'black';
  ctx.lineWidth = 2;

  const top = topTextInput.value.toUpperCase();
  const bot = bottomTextInput.value.toUpperCase();
  if (top) { ctx.fillText(top, canvas.width / 2, 40); ctx.strokeText(top, canvas.width / 2, 40); }
  if (bot) { ctx.fillText(bot, canvas.width / 2, canvas.height - 40); ctx.strokeText(bot, canvas.width / 2, canvas.height - 40); }
}

function resetMeme() {
  // ‚úÖ Remove previous listeners
  canvas.removeEventListener("mousedown", canvasMouseDown);
  canvas.removeEventListener("mousemove", canvasMouseMove);
  canvas.removeEventListener("mouseup", canvasMouseUp);
  canvas.removeEventListener("wheel", canvasWheel);

  // Clear object arrays
  hats.length = 0;
  chains.length = 0;
  characters.length = 0;

  // Reset selection state
  selectedObj = null;
  activeTouchObj = null;
  lockedObj = null;
  selectedTouchTarget = null;

  // Reset dropdowns
  bgSelect.value = "";
  hatSelect.value = "";
  chainSelect.value = "";
  characterSelect.value = "";

  // Hide rotation slider
  sliderWrapper.style.display = 'none';

  drawCanvas();

  // ‚úÖ Reattach touch/gesture logic after a short delay
  setTimeout(() => {
   window.activeTouchObj = null;
   
  [...hats, ...chains, ...characters].forEach(obj => {
    obj.dragging = false;
    obj.gestureActive = false;
    obj.offsetX = 0;
    obj.offsetY = 0;
    setupTouchHandlers(obj);
  });

  lockedObj = null;
  activeTouchObj = null;
  selectedTouchTarget = null;
 }, 50);
}

function setupAllHandlers() {
   [bgSelect, hatSelect, chainSelect, characterSelect].forEach(el =>
    el.addEventListener('change', drawMeme)
  );
  [topTextInput, bottomTextInput].forEach(el =>
    el.addEventListener('input', drawCanvas)
  );
}

function downloadMeme() {
  const link = document.createElement('a');
  link.download = 'wagmik-meme.png';
  link.href = canvas.toDataURL('image/png');
  link.click();
}

function enforceLayerOrder() {
¬† const allObjects = [...characters, ...chains, ...hats];
¬† allObjects.forEach(obj => {
¬† ¬† if (obj.role === 'character') {
¬† ¬† ¬† // Characters should draw behind
¬† ¬† ¬† const index = allObjects.indexOf(obj);
¬† ¬† ¬† if (index > -1) {
¬† ¬† ¬† ¬† allObjects.splice(index, 1);
¬† ¬† ¬† ¬† allObjects.unshift(obj);
¬† ¬† ¬† }
¬† ¬† }
¬† });
}

function deleteSelectedObject() {
  if (!selectedObj) return;

  // ‚úÖ STEP 1: Detect dropdown to reset *before* deletion
  const role = selectedObj.role;
  const imgSrc = selectedObj.img?.src || "";

  // STEP 2: Remove selectedObj from relevant array
  [hats, chains, characters].forEach(arr => {
    const index = arr.indexOf(selectedObj);
    if (index !== -1) arr.splice(index, 1);
  });

  // ‚úÖ STEP 3: Reset only the matching dropdown
  if (role === 'hat' && hatSelect.value && imgSrc.includes(hatSelect.value)) {
    hatSelect.value = '';
  }
  if (role === 'chain' && chainSelect.value && imgSrc.includes(chainSelect.value)) {
    chainSelect.value = '';
  }
  if (role === 'character' && characterSelect.value && imgSrc.includes(characterSelect.value)) {
    characterSelect.value = '';
  }

  // STEP 4: Reset state
  selectedObj = null;
  activeTouchObj = null;
  lockedObj = null;
  selectedTouchTarget = null;

  sliderWrapper.style.display = 'none'; // hide rotation slider
  drawCanvas();
}

function isInside(mx, my, x, y, w, h) {
  return mx >= x && mx <= x + w && my >= y && my <= y + h;
}

function setupDragAndResize(obj) {
  // Mouse events
  canvasMouseDown = (e) => {
    const { left, top } = canvas.getBoundingClientRect();
    const mx = e.clientX - left;
    const my = e.clientY - top;

   const clicked = getTouchTarget(mx, my, false); // false = precise mouse priority

if (clicked) {
  clicked.dragging = true;
  selectedObj = clicked;
  clickedObj = clicked;

  if (!/Mobi|Android/i.test(navigator.userAgent)) {
    sliderWrapper.style.display = 'block';
    rotationSlider.value = (clicked.rotation * 180 / Math.PI).toFixed(0);
  }
} else {
  selectedObj = null;
  sliderWrapper.style.display = 'none';
}

    if (!selectedObj) {
      sliderWrapper.style.display = 'none';
    }
  };

  canvasMouseMove = (e) => {
    const dragging = [...hats, ...chains, ...characters].find(obj => obj.dragging);
    if (!dragging) return;

    const rect = canvas.getBoundingClientRect();
    dragging.x = e.clientX - rect.left - (dragging.img.width * dragging.scale) / 2;
    dragging.y = e.clientY - rect.top - (dragging.img.height * dragging.scale) / 2;
    drawCanvas();
  };

  canvasMouseUp = () => {
    [...hats, ...chains, ...characters].forEach(obj => obj.dragging = false);
  };

  canvasWheel = (e) => {
  if (!selectedObj) return;
  e.preventDefault();

  const zoomFactor = 1.05;
  const scaleDirection = e.deltaY < 0 ? zoomFactor : 1 / zoomFactor;
  const newScale = Math.max(0.05, Math.min(4.0, selectedObj.scale * scaleDirection));

  // Get mouse position relative to canvas
  const rect = canvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;

  // Adjust object position so it zooms toward cursor
  selectedObj.x = mouseX - (mouseX - selectedObj.x) * (newScale / selectedObj.scale);
  selectedObj.y = mouseY - (mouseY - selectedObj.y) * (newScale / selectedObj.scale);

  // Apply new scale
  selectedObj.scale = newScale;

  drawCanvas();
};


 
  
  // Attach
  canvas.addEventListener("mousedown", canvasMouseDown);
  canvas.addEventListener("mousemove", canvasMouseMove);
  canvas.addEventListener("mouseup", canvasMouseUp);
  canvas.addEventListener("wheel", canvasWheel);
}


function getTouchTarget(x, y, preferTopMost = true) {
  const allObjs = preferTopMost
    ? [...hats, ...chains, ...characters]   // topmost-first for touch
    : [...characters, ...chains, ...hats]; // bottom-first for precise mouse

  for (let i = allObjs.length - 1; i >= 0; i--) {
    const obj = allObjs[i];
    const w = obj.img.width * obj.scale;
    const h = obj.img.height * obj.scale;
    const isInside =
      x >= obj.x && x <= obj.x + w &&
      y >= obj.y && y <= obj.y + h;

    if (isInside) return obj;
  }
  return null;
}

function setupTouchHandlers(obj) {
  const touchStartHandler = (e) => {
    const rect = canvas.getBoundingClientRect();
    const touch = e.touches[0];
    const x = touch.clientX - rect.left;
    const y = touch.clientY - rect.top;

    if (e.touches.length === 1) {
      lockedObj = null;
      selectedTouchTarget = null;
    }

    window.activeTouchObj = null;
    selectedTouchTarget = null;

    // Check if tapping delete button
    if (e.touches.length === 1 && obj.deleteBtnBounds) {
      const { centerX, centerY, size } = obj.deleteBtnBounds;
      const dx = x - centerX;
      const dy = y - centerY;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist <= size / 2) {
        e.preventDefault();
        selectedObj = obj;
        deleteSelectedObject();
        return;
      }
    }

    // Get top-most touched object
    const touchedObj = getTouchTarget(x, y, false);

  if (e.touches.length === 1 && touchedObj) {
  lockedObj = touchedObj;
  selectedTouchTarget = touchedObj;
  touchedObj.dragging = true;
  activeTouchObj = touchedObj;
}
    // Fallback
    if (!activeTouchObj && touchedObj) {
      activeTouchObj = touchedObj;
      lockedObj = touchedObj;
      touchedObj.dragging = true;
    }
  };

  // Clean previous handler
  if (obj._touchStartHandler) {
    canvas.removeEventListener('touchstart', obj._touchStartHandler);
  }

  canvas.addEventListener('touchstart', touchStartHandler, { passive: false });
  obj._touchStartHandler = touchStartHandler;

  // Touchmove
 canvas.addEventListener('touchmove', (e) => {
  e.preventDefault();

  const rect = canvas.getBoundingClientRect();
  const touches = e.touches;

  if (touches.length === 1 && obj === activeTouchObj && obj.dragging) {
    obj.x = touches[0].clientX - rect.left - (obj.img.width * obj.scale) / 2;
    obj.y = touches[0].clientY - rect.top - (obj.img.height * obj.scale) / 2;
    drawCanvas();
  }

  if (touches.length === 2 && obj === activeTouchObj) {
    const [t1, t2] = touches;

    const dx = t2.clientX - t1.clientX;
    const dy = t2.clientY - t1.clientY;

    const distance = Math.hypot(dx, dy);
    const angle = Math.atan2(dy, dx);

    const centerX = (t1.clientX + t2.clientX) / 2;
    const centerY = (t1.clientY + t2.clientY) / 2;

    const w = obj.img.width * obj.scale;
    const h = obj.img.height * obj.scale;

    if (!obj.gestureActive) {
      initialDist = distance;
      initialAngle = angle;
      initialScale = obj.scale;
      initialRotation = obj.rotation;

      const objCenterX = obj.x + w / 2;
      const objCenterY = obj.y + h / 2;

      obj.offsetX = objCenterX - (centerX - rect.left);
      obj.offsetY = objCenterY - (centerY - rect.top);

      obj.gestureActive = true;
    }

    const minScale = 0.05;
    const maxScale = 2.5;

    obj.scale = Math.max(minScale, Math.min(maxScale, initialScale * distance / initialDist));
    obj.rotation = initialRotation + (angle - initialAngle);

    obj.x = centerX - rect.left - w / 2 + obj.offsetX;
    obj.y = centerY - rect.top - h / 2 + obj.offsetY;

    drawCanvas();
  }
}, { passive: false });

  canvas.addEventListener('touchend', () => {
    if (obj === activeTouchObj) {
      obj.dragging = false;
      obj.gestureActive = false;
      activeTouchObj = null;
      lockedObj = null;
      selectedTouchTarget = null;
    }
  }, { passive: false });
}

[...hats, ...chains, ...characters].forEach(obj => {
  setupDragAndResize(obj);
  setupTouchHandlers(obj);
});

[bgSelect, hatSelect, chainSelect, characterSelect].forEach(el =>
  el.addEventListener('change', drawMeme)                                                         
);
bgSelect.addEventListener('change', drawCanvas);
[topTextInput, bottomTextInput].forEach(el => el.addEventListener('input', drawCanvas));
</script>

<script>
function shareToX() {
¬† const shareBtn = document.getElementById("shareBtn");
¬† const shareModal = document.getElementById("shareModal");
¬† const confirmBtn = document.getElementById("confirmShare");
¬† const cancelBtn = document.getElementById("cancelShare");

¬† shareBtn.addEventListener("click", async () => {
¬† ¬† canvas.toBlob(async (blob) => {
¬† ¬† ¬† if (!blob) return;
¬† ¬† ¬† const reader = new FileReader();
¬† ¬† ¬† reader.onloadend = () => {
¬† ¬† ¬† ¬† const link = document.createElement("a");
¬† ¬† ¬† ¬† link.href = reader.result;
¬† ¬† ¬† ¬† link.download = "wagmik-meme.png";
¬† ¬† ¬† ¬† document.body.appendChild(link);
¬† ¬† ¬† ¬† link.click();
¬† ¬† ¬† ¬† document.body.removeChild(link);

¬† ¬† ¬† ¬† shareModal.classList.remove("hidden");
¬† ¬† ¬† };
¬† ¬† ¬† reader.readAsDataURL(blob);
¬† ¬† });
¬† });

¬† cancelBtn.onclick = () => {
¬† ¬† shareModal.classList.add("hidden");
¬† };

¬† confirmBtn.onclick = () => {
¬† ¬† shareModal.classList.add("hidden");

¬† ¬† const top = topTextInput.value.trim();
¬† ¬† const bottom = bottomTextInput.value.trim();
¬† ¬† const memeText = `${top} ${bottom}`.replace(/\s+/g, ' ').trim();

¬† ¬† const tweetText = `${memeText}\n\nI just made a $WAGMIK meme! üíÄüî•\n\nüìåTry it üëâ https://wagmik.xyz`;
¬† ¬† const tweetURL = `https://twitter.com/intent/tweet?text=${encodeURIComponent(tweetText)}`;

¬† ¬† window.open(tweetURL, '_blank');
¬† };
}
</script>

 <script>
¬† shareToX(); 
</script>

<script>
  // Show popup only on mobile devices
  window.addEventListener('DOMContentLoaded', () => {
    const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
    const hasNoWallet = !window.solana && !window.backpack;

    if (isMobile && hasNoWallet) {
      document.getElementById('mobileWalletPopup').style.display = 'block';
    }
  });
</script>

<script>
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('/wagmikcoin/service-worker.js')
        .then(reg => console.log('‚úÖ Service Worker registered:', reg))
        .catch(err => console.error('‚ùå Service Worker registration failed:', err));
    });
  }
</script>

<script>
  function getClusterUrl(cluster) {
    if (cluster === "localhost") return "http://127.0.0.1:8899";
    if (cluster === "mainnet-beta") {
      return "https://mainnet.helius-rpc.com/?api-key=ab50cc7f-3c60-42b0-a3b4-4944c5263912";
    }
    return solanaWeb3.clusterApiUrl(cluster);
  }
</script>

<script>
  if (window.matchMedia('(display-mode: standalone)').matches) {
    document.body.classList.add('standalone');
  }
</script>

<script>
function waitForSplToken(maxWait = 3000) {
  return Promise.race([
    window.splTokenReady,
    new Promise((_, reject) => {
      setTimeout(() => {
        reject(new Error("‚ùå SPL Token module failed to load in time."));
      }, maxWait);
    })
  ]);
}

document.addEventListener('DOMContentLoaded', () => {
  function getClusterUrl(cluster) {
    if (cluster === "localhost") return "http://127.0.0.1:8899";
    if (cluster === "mainnet-beta") {
      return "https://mainnet.helius-rpc.com/?api-key=ab50cc7f-3c60-42b0-a3b4-4944c5263912";
    }
    return solanaWeb3.clusterApiUrl(cluster);
  }

  window.walletPublicKey = null;

  function cleanBase58Input(input) {
    return input
      .normalize("NFKD")
      .replace(/[-\u001F\u007F-\u009F\u00A0\u200B\u200C\u200D\u200E\u200F\u2028\u2029\u2060\uFEFF]/g, '')
      .replace(/[^\x21-\x7E]/g, '')
      .trim();
  }

  function logOutput(msg) {
    const output = document.getElementById("terminalOutput");
    if (!output) return;
    output.innerHTML += `\n> ${msg}`;
    output.scrollTop = output.scrollHeight;
  }

  const walletDisplay = document.getElementById('walletAddressDisplay');
  const connectBtn = document.getElementById('connectWalletBtn');
  const disconnectBtn = document.getElementById('disconnectWalletBtn');
  const runBtn = document.getElementById('runCommandBtn');
  const output = document.getElementById('terminalOutput');
  const input = document.getElementById('terminalInput');
  const modal = document.getElementById('solanaDevModal');
  const solanaIcon = document.getElementById('solanaAppIcon');

  const defaultCluster = "devnet";
  const selectedCluster = localStorage.getItem("solanaCluster") || defaultCluster;

  window.solanaConnection = new solanaWeb3.Connection(
    getClusterUrl(selectedCluster),
    "confirmed"
  );

  const airdropItem = document.querySelector(".airdropCommand");
  if (airdropItem) {
    airdropItem.style.display = selectedCluster === "mainnet-beta" ? "none" : "list-item";
  }

  const splAirdropItem = document.querySelector(".splAirdropCommand");
  if (splAirdropItem) {
    splAirdropItem.style.display = selectedCluster === "devnet" ? "list-item" : "none";
  }

  const clusterSelect = document.getElementById("clusterSelect");
  if (clusterSelect) {
    clusterSelect.value = selectedCluster;

    clusterSelect.addEventListener("change", (e) => {
      const newCluster = e.target.value;
      localStorage.setItem("solanaCluster", newCluster);
      window.solanaConnection = new solanaWeb3.Connection(getClusterUrl(newCluster), "confirmed");
      logOutput(`üîÅ Switched to cluster: ${newCluster}`);

      const airdropItem = document.querySelector(".airdropCommand");
      if (airdropItem) {
        airdropItem.style.display = newCluster === "mainnet-beta" ? "none" : "list-item";
      }

      const splAirdropItem = document.querySelector(".splAirdropCommand");
      if (splAirdropItem) {
        splAirdropItem.style.display = newCluster === "devnet" ? "list-item" : "none";
      }
    });
  }

  connectBtn?.addEventListener('click', async () => {
    try {
      if (window.solana?.isPhantom) {
        const resp = await window.solana.connect();
        window.walletPublicKey = resp.publicKey;
        walletDisplay.textContent = `‚úÖ ${window.walletPublicKey.toBase58()}`;
        logOutput("üü¢ Wallet connected.");
      } else {
        logOutput("‚ö†Ô∏è Phantom not found.");
      }
    } catch (err) {
      logOutput("‚ùå Wallet connection failed.");
    }
  });

  window.createDevnetMint = async function () {
    try {
      const mintKeypair = new solanaWeb3.Keypair();
      const lamports = await window.solanaConnection.getMinimumBalanceForRentExemption(82);

      const createAccountIx = solanaWeb3.SystemProgram.createAccount({
        fromPubkey: walletPublicKey,
        newAccountPubkey: mintKeypair.publicKey,
        space: 82,
        lamports,
        programId: window.splToken.TOKEN_PROGRAM_ID,
      });

      const initMintIx = splToken.Token.createInitMintInstruction(
        splToken.TOKEN_PROGRAM_ID,
        mintKeypair.publicKey,
        0,
        walletPublicKey,
        null
      );

      const tx = new solanaWeb3.Transaction().add(createAccountIx, initMintIx);
      const { blockhash } = await window.solanaConnection.getLatestBlockhash("confirmed");
      tx.recentBlockhash = blockhash;
      tx.feePayer = walletPublicKey;

      tx.partialSign(mintKeypair);

      const signed = await window.solana.signTransaction(tx);
      const sig = await window.solanaConnection.sendRawTransaction(signed.serialize());
      await window.solanaConnection.confirmTransaction(sig, "confirmed");

      const mint = mintKeypair.publicKey.toBase58();
      logOutput(`‚úÖ Mint created: ${mint}`);
      logOutput(`üîó <a href="${getExplorerAddressUrl(mint)}" target="_blank" style="color:#00ffa1;">View on Solscan</a>`);
    } catch (err) {
      console.error("‚ùå Mint creation failed:", err);
      logOutput("‚ùå Mint creation failed. Check console.");
    }
  };

  disconnectBtn?.addEventListener('click', async () => {
    try {
      if (window.solana?.disconnect) {
        await window.solana.disconnect();
        window.walletPublicKey = null;
        walletDisplay.textContent = "Wallet not connected";
        logOutput("üîå Wallet disconnected.");
      } else {
        logOutput("‚ö†Ô∏è Wallet doesn't support disconnect.");
      }
    } catch (err) {
      logOutput("‚ùå Disconnect failed.");
      console.error(err);
    }
  });

  runBtn?.addEventListener('click', async () => {
    const cmd = input.value.trim().toLowerCase();
    input.value = '';

    if (cmd.startsWith("spl")) {
      try {
        await waitForSplToken();
      } catch (e) {
        logOutput(e.message);
        return;
      }
    }

    if (!walletPublicKey) {
      logOutput("‚ùå Connect wallet first");
      return;
    }

    if (!window.solanaReady || !window.solanaConnection) {
      logOutput("‚ùå Solana not ready yet.");
      return;
    }

    if (cmd === 'balance') {
      try {
        const lamports = await window.solanaConnection.getBalance(walletPublicKey);
        const sol = lamports / solanaWeb3.LAMPORTS_PER_SOL;
        logOutput(`üí∞ Balance: ${sol.toFixed(4)} SOL`);
      } catch (err) {
        logOutput("‚ùå Failed to fetch balance.");
        console.error(err);
      }
    } else if (cmd === 'airdrop') {
      if (selectedCluster === "mainnet-beta") {
        logOutput("üö´ Airdrop is not available on Mainnet.");
        return;
      }
      try {
        const sig = await window.solanaConnection.requestAirdrop(walletPublicKey, solanaWeb3.LAMPORTS_PER_SOL);
        logOutput(`üö∞ Airdrop requested. TX: ${sig}`);
        await window.solanaConnection.confirmTransaction(sig, 'confirmed');
        logOutput("‚úÖ Airdrop confirmed");
        const explorer = selectedCluster === "mainnet-beta"
          ? `https://solscan.io/tx/${sig}`
          : `https://solscan.io/tx/${sig}?cluster=devnet`;
        logOutput(`üîó <a href="${explorer}" target="_blank" style="color:#00ffa1;">View on Solscan</a>`);
      } catch (err) {
        logOutput("‚ùå Airdrop failed.");
        console.error(err);
      }
    } else if (cmd === "spltokenairdrop") {
      if (selectedCluster !== "devnet") {
        logOutput("üö´ This token airdrop only works on devnet.");
        return;
      }
      try {
        const mint = new solanaWeb3.PublicKey("HFcqwsjpu7Cdc7JawyRCpJEqU4v2Tz1iELjKAwN1XxvV");
        console.log("Mint:", mint.toBase58());
        console.log("Authority (wallet):", walletPublicKey.toBase58());

        const ata = await splToken.Token.getAssociatedTokenAddress(
          splToken.ASSOCIATED_TOKEN_PROGRAM_ID,
          splToken.TOKEN_PROGRAM_ID,
          mint,
          walletPublicKey
        );

        const info = await window.solanaConnection.getAccountInfo(ata);
        const instructions = [];

        if (!info) {
          logOutput("üõ† Creating associated token account...");
          instructions.push(
            splToken.Token.createAssociatedTokenAccountInstruction(
              splToken.ASSOCIATED_TOKEN_PROGRAM_ID,
              splToken.TOKEN_PROGRAM_ID,
              mint,
              ata,
              walletPublicKey,
              walletPublicKey
            )
          );
        }

        instructions.push(
          splToken.Token.createMintToCheckedInstruction(
            splToken.TOKEN_PROGRAM_ID,
            mint,
            ata,
            walletPublicKey,
            [],
            100_000000,
            6
          )
        );

        const tx = new solanaWeb3.Transaction().add(...instructions);
        const { blockhash } = await window.solanaConnection.getLatestBlockhash("confirmed");
        tx.recentBlockhash = blockhash;
        tx.feePayer = walletPublicKey;

        const signed = await window.solana.signTransaction(tx);
        const sig = await window.solanaConnection.sendRawTransaction(signed.serialize(), { skipPreflight: true });
        logOutput("üì§ Airdrop TX submitted.");
        const explorerLink = selectedCluster === "mainnet-beta"
          ? `https://solscan.io/tx/${sig}`
          : `https://solscan.io/tx/${sig}?cluster=devnet`;
        logOutput(`üîó ${explorerLink}`);

        await window.solanaConnection.confirmTransaction(sig, "confirmed");
        logOutput("‚úÖ Token airdrop confirmed.");
      } catch (err) {
        logOutput("‚ùå Airdrop failed.");
        console.error(err);
      }
    } else if (cmd.startsWith("send ")) {
      const parts = cmd.split(" ");
      if (parts.length !== 3) {
        logOutput("‚ùå Usage: send <recipient> <amount>");
        return;
      }

      const rawInput = parts[1];
      const amount = parseFloat(parts[2]);
      const cleanedRecipient = cleanBase58Input(rawInput);

      console.log("Raw input:", JSON.stringify(rawInput));
      console.log("Cleaned recipient:", JSON.stringify(cleanedRecipient));
      console.log("Length:", cleanedRecipient.length);
      console.log("Char codes:", [...cleanedRecipient].map(c => c.charCodeAt(0)));

      let base58Valid = true;
      let decoded = null;
      try {
        decoded = bs58.decode(cleanedRecipient);
        base58Valid = decoded.length === 32;
      } catch (err) {
        base58Valid = false;
      }

      if (!base58Valid || isNaN(amount)) {
        logOutput("‚ùå Invalid recipient address or amount.");
        return;
      }

      let toPubkey;
      try {
        toPubkey = new solanaWeb3.PublicKey(cleanedRecipient);
      } catch (e) {
        logOutput(`‚ùå Invalid recipient address: ${e.message}`);
        return;
      }

      const fromPubkey = walletPublicKey;
      try {
        logOutput(`üß† Sending ${amount} SOL to ${cleanedRecipient}...`);
        const tx = new solanaWeb3.Transaction().add(
          solanaWeb3.SystemProgram.transfer({
            fromPubkey,
            toPubkey,
            lamports: amount * solanaWeb3.LAMPORTS_PER_SOL,
          })
        );

        const { blockhash } = await window.solanaConnection.getLatestBlockhash("confirmed");
        tx.recentBlockhash = blockhash;
        tx.feePayer = fromPubkey;

        const signedTx = await window.solana.signTransaction(tx);
        const signature = await window.solanaConnection.sendRawTransaction(signedTx.serialize());
        logOutput(`üì§ TX sent: ${signature}`);
        const explorer = selectedCluster === "mainnet-beta"
          ? `https://solscan.io/tx/${signature}`
          : `https://solscan.io/tx/${signature}?cluster=devnet`;
        logOutput(`üîó <a href="${explorer}" target="_blank" style="color:#00ffa1;">View on Solscan</a>`);

        await window.solanaConnection.confirmTransaction(signature, 'confirmed');
        logOutput("‚úÖ Transaction confirmed.");
      } catch (err) {
        logOutput("‚ùå Transaction failed.");
        console.error(err);
      }
    } else if (cmd === "spltokens") {
      try {
        const tokens = await window.solanaConnection.getParsedTokenAccountsByOwner(
          walletPublicKey,
          { programId: splToken.TOKEN_PROGRAM_ID }
        );

        if (!tokens.value.length) {
          logOutput("üéí No SPL tokens found.");
          return;
        }

        logOutput("üéí SPL Tokens:");
        for (const acc of tokens.value) {
          const { mint, tokenAmount } = acc.account.data.parsed.info;
          const amount = tokenAmount.uiAmountString;
          logOutput(`- ${mint}: ${amount}`);
        }
      } catch (err) {
        logOutput("‚ùå Failed to fetch SPL tokens.");
        console.error(err);
      }
    } else if (cmd.startsWith("splsend ")) {
      const parts = cmd.split(" ");
      if (parts.length !== 4) {
        logOutput("‚ùå Usage: splsend <mint> <recipient> <amount>");
        return;
      }

      const [_, mintStr, recipientStr, amountStr] = parts;
      try {
        const mint = new solanaWeb3.PublicKey(mintStr);
        const recipient = new solanaWeb3.PublicKey(recipientStr);
        const amount = parseFloat(amountStr);
        if (isNaN(amount) || amount <= 0) throw new Error("Invalid amount");

        const token = new splToken.Token(
          window.solanaConnection,
          mint,
          splToken.TOKEN_PROGRAM_ID,
          walletPublicKey
        );

        console.log("‚úÖ [SPLToken] Mint:", mint.toBase58());
        console.log("‚úÖ [SPLToken] token.publicKey:", token.publicKey.toBase58());
        console.log("‚úÖ [SPLToken] TOKEN_PROGRAM_ID:", splToken.TOKEN_PROGRAM_ID.toBase58());
        console.log("‚úÖ [SPLToken] ASSOCIATED_TOKEN_PROGRAM_ID:", splToken.ASSOCIATED_TOKEN_PROGRAM_ID.toBase58());

        if (!token.publicKey.equals(mint)) {
          console.warn("‚ö†Ô∏è Mismatch: token.publicKey !== mint");
        }

        const senderTokenAccount = await window.solanaConnection.getTokenAccountsByOwner(
          walletPublicKey,
          { mint }
        );
        if (!senderTokenAccount.value.length) {
          logOutput("‚ùå No token account found for that mint.");
          return;
        }
        const senderAccountPubkey = senderTokenAccount.value[0].pubkey;

        const ata = await splToken.Token.getAssociatedTokenAddress(
          splToken.ASSOCIATED_TOKEN_PROGRAM_ID,
          splToken.TOKEN_PROGRAM_ID,
          mint,
          recipient
        );

        const info = await window.solanaConnection.getAccountInfo(ata);
        if (!info) {
          logOutput("üõ† Creating recipient associated token account...");
          const createIx = splToken.Token.createAssociatedTokenAccountInstruction(
            splToken.ASSOCIATED_TOKEN_PROGRAM_ID,
            splToken.TOKEN_PROGRAM_ID,
            mint,
            ata,
            recipient,
            walletPublicKey
          );

          const setupTx = new solanaWeb3.Transaction().add(createIx);
          const { blockhash } = await window.solanaConnection.getLatestBlockhash("confirmed");
          setupTx.recentBlockhash = blockhash;
          setupTx.feePayer = walletPublicKey;

          const signed = await window.solana.signTransaction(setupTx);
          const sig = await window.solanaConnection.sendRawTransaction(signed.serialize(), { skipPreflight: true });
          await window.solanaConnection.confirmTransaction(sig, "confirmed");
          logOutput("‚úÖ Associated token account created.");
        }

        const mintInfo = await token.getMintInfo();
        const decimals = mintInfo.decimals;

        const tx = new solanaWeb3.Transaction().add(
          splToken.Token.createTransferCheckedInstruction(
            splToken.TOKEN_PROGRAM_ID,
            senderAccountPubkey,
            mint,
            ata,
            walletPublicKey,
            [],
            amount * Math.pow(10, decimals),
            decimals
          )
        );

        const { blockhash } = await window.solanaConnection.getLatestBlockhash("confirmed");
        tx.recentBlockhash = blockhash;
        tx.feePayer = walletPublicKey;

        const signedTx = await window.solana.signTransaction(tx);
        const sig = await window.solanaConnection.sendRawTransaction(signedTx.serialize(), { skipPreflight: true });
        logOutput(`üì§ SPL Transfer TX: ${sig}`);
        const explorer = selectedCluster === "mainnet-beta"
          ? `https://solscan.io/tx/${sig}`
          : `https://solscan.io/tx/${sig}?cluster=devnet`;
        logOutput(`üîó View: ${explorer}`);

        await window.solanaConnection.confirmTransaction(sig, "confirmed");
        logOutput("‚úÖ SPL Token transfer confirmed.");
      } catch (err) {
        if (err?.message?.includes("already been processed") || err?.logs?.join?.("").includes("already been processed")) {
          logOutput("‚ö†Ô∏è TX already processed, skipping duplicate.");
          return;
        }
        logOutput("‚ùå SPL Transfer failed.");
        console.error(err);
      }
    } else if (cmd === "dappcheck") {
      logOutput("üîç Checking dAppStore readiness...");
      const manifestEl = document.querySelector('link[rel="manifest"]');
      logOutput(`üì± manifest.json: ${manifestEl ? "‚úÖ found" : "‚ùå missing"}`);
      const swSupport = 'serviceWorker' in navigator;
      logOutput(`üõ† Service worker support: ${swSupport ? "‚úÖ yes" : "‚ùå no"}`);
      const isHttps = window.location.protocol === "https:";
      logOutput(`üîê HTTPS: ${isHttps ? "‚úÖ yes" : "‚ùå no"}`);
      const hasTheme = document.querySelector('meta[name="theme-color"]');
      logOutput(`üé® theme-color meta: ${hasTheme ? "‚úÖ present" : "‚ùå missing"}`);
      const hasPhantom = !!window.solana?.isPhantom;
      logOutput(`üëª Phantom wallet: ${hasPhantom ? "‚úÖ detected" : "‚ùå not found"}`);
      const isMobile = /Android|iPhone|iPad|SolanaMobile/i.test(navigator.userAgent);
      logOutput(`üì± Mobile environment: ${isMobile ? "‚úÖ yes" : "‚ö†Ô∏è desktop"}`);
      logOutput(`üìû Deep Link test: <a href="solana://wallet" target="_blank" style="color:#00ffa1;">solana://wallet</a>`);
      if (isMobile) {
        setTimeout(() => {
          window.location.href = "solana://wallet";
        }, 2000);
      }
      logOutput(`üì¶ dApp readiness: ‚úÖ ready`);
    } else if (cmd === "mintnft") {
      if (typeof window.runDevnetMint !== "function") {
        logOutput("‚ùå Mint function not found.");
        return;
      }
      try {
        logOutput("‚è≥ Uploading and minting...");
        await window.runDevnetMint();
        logOutput("‚úÖ Mint complete. See console for image + tx.");
      } catch (err) {
        logOutput("‚ùå Mint failed.");
        console.error(err);
      }
    } else if (cmd === "view nft") {
      output.innerHTML += "\nüì• Fetching NFTs from wallet...";
      await loadWalletNFTs();
      output.innerHTML += "\nüñº NFT Gallery loaded.";
    } else if (cmd === "createcollection") {
      if (typeof window.createCollection !== "function") {
        logOutput("‚ùå Create collection function not found.");
        return;
      }
      try {
        logOutput("‚è≥ Creating WAGMIK Meme Collection...");
        await window.createCollection();
        logOutput("‚úÖ Collection creation complete. Check console and localStorage for mint.");
      } catch (err) {
        logOutput("‚ùå Failed to create collection.");
        console.error(err);
      }
    } else {
      logOutput(`‚ùì Unknown command: ${cmd}`);
    }
  });

  function toggleSolanaDev() {
    modal?.classList.toggle('active');
  }

  solanaIcon?.addEventListener('click', toggleSolanaDev);

  // === NFT Mint/Download Popup Logic ===
  function showMemePopup() {
    document.getElementById('downloadMintPopup')?.classList.remove("hidden");
  }

  function dismissPopup() {
    document.getElementById('downloadMintPopup')?.classList.add("hidden");
  }

  function handleDownload() {
    dismissPopup();
    downloadMeme();
  }

  function handleMint() {
    input.value = "mintnft";
    modal?.classList.add("active");
    runBtn.click();
  }

// ‚úÖ NOW attach listeners AFTER functions are defined:
document.getElementById("downloadOrMintBtn")?.addEventListener("click", showMemePopup);
document.getElementById("popupDownloadBtn")?.addEventListener("click", handleDownload);
document.getElementById("popupMintBtn")?.addEventListener("click", handleMint);
document.getElementById("popupCloseBtn")?.addEventListener("click", dismissPopup);
 
});
 
</script>
 
<script>

 window.borshMetadata = {
    deserialize(buffer) {
      try {
        const name = new TextDecoder().decode(buffer.slice(1 + 32 + 32, 1 + 32 + 32 + 32)).replace(/\0/g, '');
        const symbol = new TextDecoder().decode(buffer.slice(1 + 32 + 32 + 32, 1 + 32 + 32 + 32 + 10)).replace(/\0/g, '');
        const rawUri = new TextDecoder().decode(
         buffer.slice(1 + 32 + 32 + 32 + 10, 1 + 32 + 32 + 32 + 10 + 200)
       );

       // Step 1: Remove null padding and invisible characters
       let uri = rawUri.replace(/\0/g, '').replace(/[^\x20-\x7E]/g, '').trim();

       // Step 2: If there's junk before "ipfs://", clean it
       const ipfsIndex = uri.indexOf("ipfs://");
       if (ipfsIndex > 0) {
          uri = uri.slice(ipfsIndex);
       }

        return {
          data: { name, symbol, uri }
        };
      } catch (e) {
        console.warn("‚ùå Failed to decode metadata", e);
        return null;
      }
    }
  };
 
  async function loadWalletNFTs() {
    const connection = window.solanaConnection;
    const wallet = window.walletPublicKey;
    const output = document.getElementById("terminalOutput");

    if (!wallet || !connection) {
      output.innerHTML += "\n‚ùå Wallet or connection not ready.";
      return;
    }

    const nfts = [];

    try {
      const accounts = await connection.getParsedTokenAccountsByOwner(wallet, {
        programId: window.splToken.TOKEN_PROGRAM_ID,
      });

      for (const acc of accounts.value) {
        const tokenAmount = acc.account.data.parsed.info.tokenAmount;
        const mint = acc.account.data.parsed.info.mint;

        if (tokenAmount.uiAmount !== 1 || tokenAmount.decimals !== 0) continue;

        // fetch metadata PDA
        const METADATA_PROGRAM_ID = new solanaWeb3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s");
        const [pda] = await solanaWeb3.PublicKey.findProgramAddress(
          [
            Buffer.from("metadata"),
            METADATA_PROGRAM_ID.toBuffer(),
            new solanaWeb3.PublicKey(mint).toBuffer()
          ],
          METADATA_PROGRAM_ID
        );

        const metadataAcc = await connection.getAccountInfo(pda);
        if (!metadataAcc) continue;

        const decoded = window.borshMetadata?.deserialize(metadataAcc.data);
        if (!decoded || !decoded.data || !decoded.data.uri) continue;

       let uri = decoded.data.uri;
         uri = uri.replace(/\0/g, '').replace(/[^\x20-\x7E]/g, '').trim();

       if (uri.startsWith("ipfs://")) {
         uri = uri.replace("ipfs://", "https://ipfs.io/ipfs/");
       }


      let json;
      try {
        const res = await fetch(uri);
        json = await res.json();
      } catch (e) {
        console.warn("‚ùå Failed to fetch metadata JSON:", uri);
        continue;
      }

        if (!json || !json.name || !json.image) continue;

       let image = json.image?.trim() || "";
       if (image.startsWith("ipfs://")) {
           image = image.replace("ipfs://", "https://ipfs.io/ipfs/");
       }

        nfts.push({
         name: json.name,
         image,  // ‚úÖ use the cleaned one
         mint
       });

      }

      // show popup
      renderNFTGallery(nfts);
    } catch (err) {
      console.error("‚ùå Failed to load NFTs", err);
      output.innerHTML += "\n‚ùå Failed to fetch NFTs.";
    }
  }
 
  function renderNFTGallery(nfts) {
    const popup = document.getElementById("nftGalleryPopup");
    const container = document.getElementById("nftGalleryContent");

    container.innerHTML = "";

    if (!nfts.length) {
      container.innerHTML = "<p>No NFTs found.</p>";
    } else {
      for (const nft of nfts) {
        const div = document.createElement("div");
        div.style.textAlign = "center";

        const img = document.createElement("img");
        img.src = nft.image;
        img.alt = nft.name;
        img.style.width = "120px";
        img.style.borderRadius = "12px";

        const label = document.createElement("div");
        label.innerText = nft.name;
        label.style.color = "#fff";
        label.style.marginTop = "4px";
        label.style.fontSize = "0.9em";

        div.appendChild(img);
        div.appendChild(label);
        container.appendChild(div);
      }
    }

    popup.classList.remove("hidden");
  }
</script>


 

<style>
@media screen and (min-width: 769px) {
  .glass-box {
    display: inline-block !important;
    background: rgba(0, 0, 0, 0.25) !important;
    backdrop-filter: blur(4px) !important;
    -webkit-backdrop-filter: blur(4px) !important;
    border-radius: 12px !important;
    padding: 8px 12px !important;
    margin: 10px auto !important;
    box-shadow: 0 0 6px rgba(0, 0, 0, 0.2) !important;
    text-align: center !important;
  }
}
</style>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    if (!window.solanaWeb3) {
      console.error("‚ùå Solana SDK not loaded.");
      return;
    }

    // Use stored or default cluster
    const defaultCluster = "devnet";
    const selectedCluster = localStorage.getItem("solanaCluster") || defaultCluster;

    window.solanaConnection = new solanaWeb3.Connection(
      getClusterUrl(selectedCluster),
      "confirmed"
    );

    window.SolanaTools = {
      PublicKey: solanaWeb3.PublicKey,
      LAMPORTS_PER_SOL: solanaWeb3.LAMPORTS_PER_SOL,
      Transaction: solanaWeb3.Transaction,
      SystemProgram: solanaWeb3.SystemProgram,
      ...(window.splToken && {
        Token: splToken.Token,
        TOKEN_PROGRAM_ID: splToken.TOKEN_PROGRAM_ID
      })
    };

    window.solanaReady = true;

    console.log("‚úÖ Solana SDK ready.");
  });
</script>

<script type="module">
  import bs58Module from 'https://cdn.jsdelivr.net/npm/bs58@5.0.0/+esm';
  console.log('bs58 module imported:', bs58Module);
  window.bs58 = bs58Module;
  window.__debug_bs58 = bs58Module;
</script>

<script type="module">
  import { Buffer } from 'https://cdn.jsdelivr.net/npm/buffer@6.0.3/+esm';
  window.Buffer = Buffer;
  console.log('‚úÖ Buffer polyfill added');
</script>

<!-- Mobile Wallet Popup -->
<div id="mobileWalletPopup" class="mobile-popup">
  <div class="popup-content">
    <p>üëã Welcome to WAGMIK!<br>
      To connect your wallet, please visit:<br>
      <strong>wagmik.xyz</strong><br>
      using your <strong>Phantom</strong>, <strong>Solflare</strong>, or <strong>Backpack</strong> app browser.
    </p>
    <button onclick="document.getElementById('mobileWalletPopup').style.display='none'">Got it!</button>
  </div>
</div>
 
<script src="https://cdn.jsdelivr.net/npm/@solana/web3.js@1.95.1/lib/index.iife.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@solana/spl-token@0.1.8/lib/index.iife.min.js"></script>

<script>
window.addEventListener("DOMContentLoaded", () => {
  function logOutput(msg) {
    const output = document.getElementById("terminalOutput");
    if (output) {
      output.innerHTML += `\n> ${msg}`;
      output.scrollTop = output.scrollHeight;
    } else {
      console.log("[logOutput fallback]", msg);
    }
  }

  // New createCollection function
  window.createCollection = async function () {
    const phantom = window.solana;
    if (!phantom || !phantom.isPhantom) return alert("Phantom not found.");
    await phantom.connect();
    const from = phantom.publicKey;

    const connection = new solanaWeb3.Connection("https://mainnet.helius-rpc.com/?api-key=ab50cc7f-3c60-42b0-a3b4-4944c5263912");
    const mint = solanaWeb3.Keypair.generate();
    const lamports = await connection.getMinimumBalanceForRentExemption(82);

    const ata = await splToken.Token.getAssociatedTokenAddress(
      splToken.ASSOCIATED_TOKEN_PROGRAM_ID,
      splToken.TOKEN_PROGRAM_ID,
      mint.publicKey,
      from
    );

    const tx = new solanaWeb3.Transaction();
    tx.add(
      solanaWeb3.SystemProgram.createAccount({
        fromPubkey: from,
        newAccountPubkey: mint.publicKey,
        space: 82,
        lamports,
        programId: splToken.TOKEN_PROGRAM_ID,
      }),
      splToken.Token.createInitMintInstruction(
        splToken.TOKEN_PROGRAM_ID,
        mint.publicKey,
        0,
        from,
        from
      ),
      splToken.Token.createAssociatedTokenAccountInstruction(
        splToken.ASSOCIATED_TOKEN_PROGRAM_ID,
        splToken.TOKEN_PROGRAM_ID,
        mint.publicKey,
        ata,
        from,
        from
      ),
      splToken.Token.createMintToInstruction(
        splToken.TOKEN_PROGRAM_ID,
        mint.publicKey,
        ata,
        from,
        [],
        1
      )
    );

    const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash("finalized");
    tx.recentBlockhash = blockhash;
    tx.feePayer = from;

    tx.partialSign(mint);
    const signed = await phantom.signTransaction(tx); 
    const txid = await connection.sendRawTransaction(signed.serialize(), { skipPreflight: false });
    await connection.confirmTransaction({ signature: txid, blockhash, lastValidBlockHeight }, "confirmed");

    console.log("‚úÖ Collection Mint TX:", txid);

    const metadata = {
      name: "WAGMIK Meme Collection",
      symbol: "WAGMIK",
      description: "A collection of memes forged in hopium. Minted on Solana.",
      image: "ipfs://QmbpEHy6METd6Ys2VAQ7MCRdG8v4W3UbEE7TozkVQdwTFb",
      seller_fee_basis_points: 0,
      external_url: "https://wagmik.xyz",
      collection: { name: "WAGMIK", family: "WAGMIK" },
      properties: {
        category: "image",
        creators: [{ address: from.toBase58(), share: 100 }],
        files: [{ uri: "ipfs://QmVFnSKo9hPtWZGPTGgQzxcuBf9HwxhWs5k5ErbXTRy8Zy", type: "image/png" }],
      },
    };

    const pinataRes = await fetch("https://api.pinata.cloud/pinning/pinJSONToIPFS", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySW5mb3JtYXRpb24iOnsiaWQiOiJjYWZkMTliZC04YTc3LTRiM2MtOGE1Zi00YWM4N2I0YjgxMmMiLCJlbWFpbCI6ImJ1c2NoZXJ0b205MkBnbWFpbC5jb20iLCJlbWFpbF92ZXJpZmllZCI6dHJ1ZSwicGluX3BvbGljeSI6eyJyZWdpb25zIjpbeyJkZXNpcmVkUmVwbGljYXRpb25Db3VudCI6MSwiaWQiOiJGUkExIn0seyJkZXNpcmVkUmVwbGljYXRpb25Db3VudCI6MSwiaWQiOiJOWUMxIn1dLCJ2ZXJzaW9uIjoxfSwibWZhX2VuYWJsZWQiOmZhbHNlLCJzdGF0dXMiOiJBQ1RJVkUifSwiYXV0aGVudGljYXRpb25UeXBlIjoic2NvcGVkS2V5Iiwic2NvcGVkS2V5S2V5IjoiNTRkMTFjZGZlNzc2MzkyN2MzN2MiLCJzY29wZWRLZXlTZWNyZXQiOiJlMDA2YWNjZGVjODFmZWI4YmQ2NjFhMTQ3N2NjYmE4N2ZmNTc2MzVmOTY2ZGVjOGFmZDlhNjc5ZDZiODRkMTA0IiwiZXhwIjoxNzg1NzcxNTA4fQ._-B0ktHsg3mTToG2JnJTvS52f0x-n5BDvnSA6jBn7Aw`,
      },
      body: JSON.stringify({ pinataMetadata: { name: metadata.name }, pinataContent: metadata }),
    });

    if (!pinataRes.ok) throw new Error("‚ùå Pinata upload failed: " + pinataRes.statusText);

    const result = await pinataRes.json();
    const metadataUri = `ipfs://${result.IpfsHash}`;
    console.log("üì¶ Collection Metadata URI:", metadataUri);

   const response = await fetch("/create-metadata", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({
    mint: mint.publicKey.toBase58(),
    payer: from.toBase58(),
    updateAuthority: from.toBase58(),
    uri: metadataUri,
    name: metadata.name,
    symbol: metadata.symbol,
    collectionMint: null,
  }),
});

if (!response.ok) {
  const text = await response.text(); // safely parse even if not JSON
  throw new Error(`‚ùå Backend error: ${text}`);
}

const { instruction, feePayer } = await response.json();


console.log("üß™ Instruction data type:", typeof instruction.data);
console.log("üß™ Instruction data (raw):", instruction.data);

   const ix = new solanaWeb3.TransactionInstruction({
  keys: instruction.keys.map(k => ({
    pubkey: new solanaWeb3.PublicKey(k.pubkey),
    isSigner: k.isSigner,
    isWritable: k.isWritable,
  })),
  programId: new solanaWeb3.PublicKey(instruction.programId),
  data: instruction.data instanceof Uint8Array
    ? instruction.data
    : Uint8Array.from(instruction.data),
});

   const freshBlock = await connection.getLatestBlockhash("finalized");
   
    const metadataTx = new solanaWeb3.Transaction({
      feePayer: new solanaWeb3.PublicKey(feePayer),
      recentBlockhash: freshBlock.blockhash,
    }).add(ix);

    const signed2 = await phantom.signTransaction(metadataTx);
    const txid2 = await connection.sendRawTransaction(signed2.serialize(), { skipPreflight: false });
    await connection.confirmTransaction({ signature: txid2, blockhash: freshBlock.blockhash, lastValidBlockHeight: freshBlock.lastValidBlockHeight }, "confirmed");

    console.log("‚úÖ Collection Metadata TX:", `https://solscan.io/tx/${txid2}${selectedCluster === "mainnet-beta" ? "" : "?cluster=devnet"}`);

    localStorage.setItem("wagmikCollectionMint", mint.publicKey.toBase58());

    logOutput(`‚úÖ Collection Mint: ${mint.publicKey.toBase58()}`);
    logOutput(`üîó https://solscan.io/address/${mint.publicKey.toBase58()}${selectedCluster === "mainnet-beta" ? "" : "?cluster=devnet"}`);

    logOutput(`‚úÖ Metadata set: ${metadataUri}`);
    logOutput(`üîó https://solscan.io/tx/${txid2}${selectedCluster === "mainnet-beta" ? "" : "?cluster=devnet"}`);

  };

  // Updated runDevnetMint
  window.runDevnetMint = async function () {
    const TOKEN_PROGRAM_ID = splToken.TOKEN_PROGRAM_ID;
    const ASSOCIATED_TOKEN_PROGRAM_ID = splToken.ASSOCIATED_TOKEN_PROGRAM_ID;
    const METADATA_PROGRAM_ID = new solanaWeb3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s");

    const canvas = document.getElementById("memeCanvas");
    if (!canvas) return alert("Meme canvas not found.");

    const tier = getRandomTier();
    const emblem = new Image();
    emblem.src = `${tier.toLowerCase().replace(/ /g, "-")}.png`;

    await new Promise(resolve => {
      emblem.onload = () => {
        ctx.drawImage(emblem, 0, 0, 360, 360);
        resolve();
      };
    });

    const mintNumber = Math.floor(Math.random() * 9999);
    const tierSlug = tier.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/-+$/, "");
    const filename = `${tierSlug}-${mintNumber}.png`;

    const rawName = `${tier} #${mintNumber}`;
    const safeName = rawName.slice(0, 32);

    const blob = await new Promise(resolve => canvas.toBlob(resolve, "image/png"));

    if (!blob || blob.size < 1000) {
      alert("‚ö†Ô∏è Meme image is too small or failed to render.");
      return;
    }

    const formData = new FormData();
    formData.append("file", blob, filename);

    const jwt = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySW5mb3JtYXRpb24iOnsiaWQiOiJjYWZkMTliZC04YTc3LTRiM2MtOGE1Zi00YWM4N2I0YjgxMmMiLCJlbWFpbCI6ImJ1c2NoZXJ0b205MkBnbWFpbC5jb20iLCJlbWFpbF92ZXJpZmllZCI6dHJ1ZSwicGluX3BvbGljeSI6eyJyZWdpb25zIjpbeyJkZXNpcmVkUmVwbGljYXRpb25Db3VudCI6MSwiaWQiOiJGUkExIn0seyJkZXNpcmVkUmVwbGljYXRpb25Db3VudCI6MSwiaWQiOiJOWUMxIn1dLCJ2ZXJzaW9uIjoxfSwibWZhX2VuYWJsZWQiOmZhbHNlLCJzdGF0dXMiOiJBQ1RJVkUifSwiYXV0aGVudGljYXRpb25UeXBlIjoic2NvcGVkS2V5Iiwic2NvcGVkS2V5S2V5IjoiNTRkMTFjZGZlNzc2MzkyN2MzN2MiLCJzY29wZWRLZXlTZWNyZXQiOiJlMDA2YWNjZGVjODFmZWI4YmQ2NjFhMTQ3N2NjYmE4N2ZmNTc2MzVmOTY2ZGVjOGFmZDlhNjc5ZDZiODRkMTA0IiwiZXhwIjoxNzg1NzcxNTA4fQ._-B0ktHsg3mTToG2JnJTvS52f0x-n5BDvnSA6jBn7Aw";

    const imageRes = await fetch("https://api.pinata.cloud/pinning/pinFileToIPFS", {
      method: "POST",
      headers: { Authorization: `Bearer ${jwt}` },
      body: formData
    });

    if (!imageRes.ok) return alert("Image upload to IPFS failed.");

    const imageResult = await imageRes.json();
    const imageUrl = `ipfs://${imageResult.IpfsHash}`;
    console.log("‚úÖ Uploaded image to IPFS:", imageUrl);

    const phantom = window.solana;
    if (!phantom || !phantom.isPhantom) return alert("Phantom not found.");
    await phantom.connect();
    const from = phantom.publicKey;

    const metadata = {
      name: safeName,
      symbol: "WAGMIK",
      description: "Forged in hopium. Minted on Solana.",
      seller_fee_basis_points: 0,
      attributes: [
        { trait_type: "Origin", value: "WAGMIK Generator" },
        { trait_type: "Chain", value: "Solana" },
        { trait_type: "Tier", value: tier }
      ],
      collection: { name: "WAGMIK", family: "WAGMIK" },
      properties: {
        category: "image",
        creators: [{ address: from.toBase58(), share: 100 }]
      }
    };

    metadata.name = metadata.name.slice(0, 32);
    metadata.symbol = metadata.symbol.slice(0, 10);
    metadata.image = imageUrl;
    metadata.properties.files = [{ uri: imageUrl, type: "image/png" }];

    const defaultCluster = "devnet";
    const selectedCluster = localStorage.getItem("solanaCluster") || defaultCluster;
    const connection = new solanaWeb3.Connection(getClusterUrl(selectedCluster), "confirmed");

    const mint = solanaWeb3.Keypair.generate();
    const lamports = await connection.getMinimumBalanceForRentExemption(82);

    const ata = await splToken.Token.getAssociatedTokenAddress(
      ASSOCIATED_TOKEN_PROGRAM_ID,
      TOKEN_PROGRAM_ID,
      mint.publicKey,
      from
    );

    const tx = new solanaWeb3.Transaction();
    tx.add(
      solanaWeb3.SystemProgram.createAccount({
        fromPubkey: from,
        newAccountPubkey: mint.publicKey,
        space: 82,
        lamports,
        programId: TOKEN_PROGRAM_ID
      }),
      splToken.Token.createInitMintInstruction(
        TOKEN_PROGRAM_ID,
        mint.publicKey,
        0,
        from,
        from
      ),
      splToken.Token.createAssociatedTokenAccountInstruction(
        ASSOCIATED_TOKEN_PROGRAM_ID,
        TOKEN_PROGRAM_ID,
        mint.publicKey,
        ata,
        from,
        from
      ),
      splToken.Token.createMintToInstruction(
        TOKEN_PROGRAM_ID,
        mint.publicKey,
        ata,
        from,
        [],
        1
      )
    );

    const [metadataPDA] = await solanaWeb3.PublicKey.findProgramAddress(
      [Buffer.from("metadata"), METADATA_PROGRAM_ID.toBuffer(), mint.publicKey.toBuffer()],
      METADATA_PROGRAM_ID
    );

    const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash("finalized");
    tx.recentBlockhash = blockhash;
    tx.feePayer = from;

    tx.partialSign(mint);
    const signed = await phantom.signTransaction(tx);
    signed.verifySignatures = false;

    const txid = await connection.sendRawTransaction(signed.serialize(), { skipPreflight: false });
    await connection.confirmTransaction({ signature: txid, blockhash, lastValidBlockHeight }, "confirmed");

    const explorerLink = selectedCluster === "mainnet-beta"
      ? `https://solscan.io/tx/${txid}`
      : `https://solscan.io/tx/${txid}?cluster=devnet`;
    logOutput(`üì¶ TX Confirmed`);
    logOutput(`üîó <a href="${explorerLink}" target="_blank" style="color:#00ffa1;">View on Solscan</a>`);

    metadata.name = (metadata.name || "").slice(0, 32).replace(/[^\x20-\x7E]/g, '');
    metadata.symbol = (metadata.symbol || "").slice(0, 10).replace(/[^\x20-\x7E]/g, '');
    metadata.image = imageUrl;
    metadata.properties.files = [{ uri: imageUrl, type: "image/png" }];

    const pinataRes = await fetch("https://api.pinata.cloud/pinning/pinJSONToIPFS", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${jwt}`
      },
      body: JSON.stringify({
        pinataMetadata: { name: metadata.name },
        pinataContent: metadata
      })
    });

    if (!pinataRes.ok) throw new Error("‚ùå Pinata upload failed: " + pinataRes.statusText);

    const result = await pinataRes.json();
    const metadataUri = `ipfs://${result.IpfsHash}`;
    console.log("üì¶ Pinata Metadata URI:", metadataUri);

    console.log("üì§ Sending metadata to backend:", {
      mint: mint.publicKey.toBase58(),
      payer: from.toBase58(),
      updateAuthority: from.toBase58(),
      uri: metadataUri,
      name: metadata.name,
      symbol: metadata.symbol
    });

    const cleanUri = (metadataUri || "").trim().slice(0, 200).replace(/[^\x20-\x7E]/g, '');
    const cleanName = (metadata.name || "").trim().slice(0, 32).replace(/[^\x20-\x7E]/g, '');
    const cleanSymbol = (metadata.symbol || "").trim().slice(0, 10).replace(/[^\x20-\x7E]/g, '');

    console.log("üßº Cleaned URI:", cleanUri, cleanUri.length);
    console.log("üßº Cleaned Name:", cleanName, cleanName.length);
    console.log("üßº Cleaned Symbol:", cleanSymbol, cleanSymbol.length);

    const collectionMint = localStorage.getItem("wagmikCollectionMint");
    if (!collectionMint) return alert("Collection not created. Please create a collection first.");

   // Fetch metadata instruction and feePayer from backend
const response = await fetch("http://localhost:3001/create-metadata", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({
    mint: mint.publicKey.toBase58(),
    payer: from.toBase58(),
    updateAuthority: from.toBase58(),
    uri: metadataUri,
    name: metadata.name,
    symbol: metadata.symbol,
    collectionMint: null,
  }),
});

if (!response.ok) {
  const text = await response.text();
  throw new Error(`‚ùå runDevnetMint metadata error: ${text}`);
}

const { instruction, feePayer } = await response.json();

console.log("üßæ Received metadata instruction:", instruction);

console.log("üß™ Received instruction in runDevnetMint:", instruction);
console.log("üß™ Type of instruction.data:", typeof instruction.data);

const ix = new solanaWeb3.TransactionInstruction({
  keys: instruction.keys.map(k => ({
    pubkey: new solanaWeb3.PublicKey(k.pubkey),
    isSigner: k.isSigner,
    isWritable: k.isWritable,
  })),
  programId: new solanaWeb3.PublicKey(instruction.programId),
  data: instruction.data instanceof Uint8Array
    ? instruction.data
    : Uint8Array.from(instruction.data),
});

const freshBlock = await connection.getLatestBlockhash("finalized");

const metadataTx = new solanaWeb3.Transaction({
  feePayer: new solanaWeb3.PublicKey(feePayer),
  recentBlockhash: freshBlock.blockhash,
}).add(ix);

const signedTx = await window.solana.signTransaction(metadataTx);
const txid2 = await connection.sendRawTransaction(signedTx.serialize(), {
  skipPreflight: true,
  maxRetries: 5,
});
await connection.confirmTransaction({ signature: txid2, blockhash: freshBlock.blockhash, lastValidBlockHeight: freshBlock.lastValidBlockHeight }, "finalized");

const metadataExplorerUrl = selectedCluster === "mainnet-beta"
  ? `https://solscan.io/tx/${txid2}`
  : `https://solscan.io/tx/${txid2}?cluster=devnet`;

logOutput(`‚úÖ Metadata set: ${metadataUri}`);
logOutput(`üîó <a href="${metadataExplorerUrl}" target="_blank" style="color:#00ffa1;">View Metadata on Solscan</a>`);
  };
  console.log("‚úÖ runDevnetMint is ready.");
});
</script>
  
 </body>
</html>


